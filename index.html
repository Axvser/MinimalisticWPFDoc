<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/2.0.0/marked.min.js"></script>
    <style>
        header {
            background: #363333;
            color: white;
            padding: 10px 0;
            text-align: center;
            border-radius: 10px;
        }

        div {
            border-radius: 14px;
            border-radius: 10px;
        }

        h1,
        h2,
        h3 {
            color: #00fff2;
        }

        h4 {
            color: violet;
        }

        option {
            background-color: #363333;
            color: #00fff2;
        }

        p {
            color: #ffffff;
        }

        li {
            color: bisque;
        }

        select {
            margin: 10px 0;
            border-radius: 10px;
        }

        section {
            margin: 20px 0;
            padding: 15px;
            background: #363333;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        code {
            background: none;
            color: aliceblue;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .red-text {
            color: red;
            font-size: 28px;
        }

        /* 自定义选择框样式 */
        .custom-select {
            color: rgb(88, 222, 255);
            /* 文字颜色 */
            background-color: #363333;
            /* 背景颜色 */
            width: 10%;
            /* 宽度 */
            padding: 5px;
            /* 内边距 */
            border-radius: 5px;
            /* 圆角 */
            cursor: pointer;
            /* 鼠标指针样式 */
            transition: background-color 0.3s, color 0.3s;
            /* 过渡效果 */
        }

        .custom-select:hover {
            background-color: #95d4de7a;
        }

        .custom-select:focus {
            background-color: #444;
        }
    </style>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 50px;
            background-color: #595757;
        }

        .code-container {
            position: relative;
            background-color: #282c34;
            color: #fff;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            /* 每个框之间的间距 */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #61dafb;
            border: none;
            color: #282c34;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="app">
        <header>
            <h1>MinimalisticWPF</h1>
            <p style="color: aquamarine;">探索简洁、清晰、易于管理的WPF动画实现方案</p>
            <p style="color: aliceblue;">{{ version }}</p>
        </header>
        <section v-show="version === '1.5.x'">
            <h2>API 文档 V{{ version }}</h2>
            <select v-model="version" class="custom-select">
                <option value="1.5.x">V1.5.x</option>
                <option value="1.8.x">V1.8.x</option>
            </select>
            <div v-html="renderedMarkdown"></div>
        </section>


        <section v-show="version === '1.8.x'">
            <h2>API 文档 V{{ version }}</h2>
            <select v-model="version" class="custom-select">
                <option value="1.5.x">V1.5.x</option>
                <option value="1.8.x">V1.8.x</option>
            </select>
            <h3 style="color: aquamarine;">Ⅰ State</h3>
            <p>State用于记录特定时刻对象的属性值,状态机运作时,会使得对象的属性值最终渐变为State内部记录的属性值,这个过程称作从一个状态(State)过渡至另一个状态</p>
            <h4>示例1. 依赖于实例对象,动态地记录属性值</h4>
            <div id="18x_FromObject"></div>
            <h4>示例2. 不依赖于实例对象,静态地记录属性值</h4>
            <div id="18x_FromType"></div>
            <h4>示例3. 对象可基于已记录的State,启动过渡</h4>
            <div id="18x_StateBegin"></div>

            <h3 style="color: aquamarine;">Ⅱ StateVector</h3>
            <p>StateVector用于描述当一个对象满足指定条件时，它应该自动地加载指向哪个State的过渡，也就是状态机特有的【条件切换】功能</p>
            <p>它会在MVVM模式下使用，你需要让ViewModel实现IConditionalTransition接口，接着在ViewModel内统一建立若干State和一个StateVector，那么当你在控件初始化时调用
                this.StateMachineLoading(ViewModel) 后，这个控件的部分属性值变动时，可以自动检查是否满足你设置的条件，如果满足，加载动画到指定State</p>
            <h4>示例. MButton是一个用户控件，使用StateVector实现鼠标悬停改变背景透明度效果</h4>
            <p>ViewModel定义</p>
            <div id="18x_StateVectorViewModel"></div>
            <p>MButton初始化</p>
            <div id="18x_StateVectorView"></div>

            <h3 style="color: aquamarine;">Ⅲ Any Class Transition</h3>
            <p>就没有更方便的写法来启动动画吗？</p>
            <p>有的，其实任何类型的实例对象都拥有统一的API用于快速启动动画效果，状态机加载动画的过程就是对属性值进行平滑修改，因此任何实例对象都可以像下方示例这样启动动画,但前提是，你在SetProperty()内部定义变化时，这个变化的内容必须是一个属性，且属性可读可写</p>
            <h4>示例1. 为一个名为GD的Grid控件同时加载旋转、平移、缩放、变色动画</h4>
            <div id="18x_GDAnimation"></div>
            <p>其实这个创建动画的过程是可以存储起来复用的,和State差不多,但它是个TransitionBoard类型的实例</p>
            <h4>实例2. 复用动画创建过程</h4>
            <div id="18x_Board"></div>
            <h4>实例3. 判断对象满足指定条件后,从State或TransitionBoard加载动画</h4>
            <div id="18x_IsSatisfy"></div>

            <h3 style="color: aquamarine;">Ⅳ 生命周期 - TransitionParams参数</h3>
            <p>动画是以帧为单位执行的,状态机加载动画时,你可在每帧开始前、每帧完成后、开始加载前、加载完成时分别执行自定义事件</p>
            <h4>可在Action&lt;TransitionParams&gt;设置以下Action委托以丰富动画过程中的行为</h4>
            <ul>
                <li>Start</li>
                <li>Update</li>
                <li>LateUpdate</li>
                <li>Completed</li>
            </ul>
            <div id="18x_LifeCircle"></div>

            <h3 style="color: aquamarine;">Ⅴ UnSafe机制 - TransitionParams参数</h3>
            <p>1.8.0及更高版本</p>
            <p>允许你将复杂动画拆解为若干分量,这将使得动画创建变得像搭积木那样有趣</p>
            <p>不过正如机制本身的名字一样,它并不是安全的,如果有两个“积木”描述的动画分量是存在冲突的,那动画必定会抽搐;或者A分量修改的属性P1在其set器内会修改属性p2,而B分量修改的属性p2在其set器内会修改属性p1,这时就可能导致严重的问题</p>
            <h4>可在Action&lt;TransitionParams&gt;设置IsUnsafe为true来启用该机制</h4>
            <div id="18x_TwoGD"></div>

            <h3 style="color: aquamarine;">Ⅵ 最佳实践</h3>
            <h4>示例1. MVVM模式下,实现一个密码框,它的边框颜色会依据当前密码强度动态修改</h4>
            <div id="18x_MPwd"></div>
            <h4>示例2. 非MVVM模式,管理多个对象的动画行为</h4>
            <div id="18x_LotOfActions"></div>
        </section>

        <!-- Vue 实例 -->
        <script>
            new Vue({
                el: '#app',
                data: {
                    version: '1.8.x',
                    renderedMarkdown:''
                },
                mounted() {
                    // 直接在此定义 Markdown 内容
                    const markdownContent = `
## 修改 
<details>
<summary>V1.5.0 即将弃用</summary>

  - Transition() 改为支持任何 [ where T : class ,new() ] 类型
  - State限制修改，需要是公开静态字段或公开属性
  - StateVector限制修改，需要写作公开属性
  - 支持Transform过渡
    - Translate
    - Scale
    - Rotate
  - 支持Point过渡
  - 支持CornerRadius过渡
  - 支持Thickness过渡
  - 接口ILinearInterpolation允许自定义的类型作为可过渡属性
</details>

<details>
<summary>V1.5.1 即将弃用</summary>

  - Acceleration 加速度支持
  - 删除状态机运作时,部分不必要的对象生成操作 
</details>

<details>
<summary>V1.5.2 即将弃用</summary>

  - 修复了NET6.0框架下动画效果异常的问题
</details>

<details>
<summary>V1.5.3 即将弃用</summary>

  - State 性能优化
    - 基于 Object
      - 在State初始化时执行了大量反射、LINQ操作
      - 允许自动化地记录一个object所有受支持的属性
    - 基于 Type
      - 在State初始化时不执行任何反射、LINQ操作
      - 只能手动指定需要修改的属性
    - 使用
      - State.FromType<>() / StateMachineTransition( StateRecordModes.Type )
      - State.FromObject() / StateMachineTransition( StateRecordModes.Object )
  - TransitionInterpreter 逻辑优化
    - 解决了频繁切换State可能导致的抽搐问题
</details>

<details>
<summary>V1.5.6</summary>

  - 修复
    - 帧率处于 57~61 时，渐变结果可能失真
    - 帧率低于 100 时，高速切换State可能导致启动状态机失败
    - 帧率为 0 时，出现错误
    - 持续时间为 0 时，出现错误
  - 调整
    - 帧率默认值已调整为 120Hz
    - 帧率限制为 1~240 ,超出范围将被自动矫正
  - 新增
    - class.IsSatisfy() 允许你基于实例对象是否满足指定的条件,决定是否启动预先描述的过渡
    \`\`\`csharp
            var board = GD.Transition()
                .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
                .SetParams((x) =>
                {
                    x.Duration = 3;
                    x.Acceleration = 1;
                });

            var result = GD.IsSatisfy(x => x.Width < 1000, board, true);
            //参数1.条件(必须)
            //参数2.若满足条件,则执行此过渡(非必须)
            //参数3.过渡效果若为基于对象的,是否启用白名单机制(非必须)
    \`\`\`
  - 2.0.0 版本预告
    - ★ 对文档进行大幅优化
    - ★ 开放更多原本只可以在状态机系统内部运作的功能
    - 修复更多潜在问题
    - 尝试进一步优化性能   
    - 增加更多常用的扩展方法
    - ⚠ 移除所有非核心组件
</details>

## 核心功能
- [状态机系统 - 对指定实例的指定属性创建线性过渡](#状态机系统)
    - [StateMachine 执行过渡功能的核心组件]() 
    - [TransitionParams 调整过渡效果细节]()
    - [MVVM 使用State与StateVector]()
    - 可参与状态机过渡的属性类型
      - double
      - Brush
      - Transform      
      - CornerRadius
      - Thickness
      - Point
      - ★ ILinearInterpolation ( 该接口使得任意自定义类型支持状态机过渡 )
## 辅助功能
- [扩展方法](#扩展方法)
    - [string]
      - 值转换
      - 模糊匹配
      - 分析工具（例如提取html中的资源地址）
      - 密码强度
- [用户控件](#用户控件)
    - 统一的深色主题
    - 字体大小自适应控件高度
    - 所有动画效果都基于状态机系统,它们既是直接可用的,也是状态机系统的实践
      - Notification - 玻璃风格的通知/选择框
      - MProgressBar - 条状/环状自由切换的进度条
      - MTopBar - 程序顶侧栏
## 非核心组件
###### MinimalisticWPF命名空间不包括下述服务，另需引用
- [Web服务](#Web服务)
  - [ 高德 ] WebApi
    - IP服务
    - 天气服务

## 支持框架
- [.NET6.0-windows] 
- [.NET8.0-windows]
## 获取
- [github][1]
- [nuget][2]

[1]: https://github.com/ChengduNeusoftUniversity-FengJunjie-Y22/MinimalisticWPF
[2]: https://www.nuget.org/packages/MinimalisticWPF/

---

# 状态机系统
- State & StateVecotr 为MVVM而生 ,可通过预先设置条件实现状态的自动切换
- StateMachine 理论可对任何类型的属性做出线性过渡，非MVVM下，几乎所有类型都包含一个用于快速为对象实例创建线性过渡的扩展方法，这可能是该类库最常用的方法
- ★ 优势
  - 以少量代码创建复杂过渡效果
  - 像游戏开发引擎那样,可在Update()中决定过渡效果的每一帧你要做出的行为
  - 功能并不局限于动画,它修改任何可能的类型、任何可能的属性,例如使用模拟数据对程序进行测试正是作者在尝试中的用法之一
- ⚠ 劣势
  - 性能不稳定 ( 相对于StoryBoard与VisualState等组件而言 )
  - 支持过渡的属性类型受限较大，虽然提供了接口以解决这个问题，但将线性插值的计算交由接口的实现类仍然不是方便的做法
[![pAu2vOP.md.png](https://s21.ax1x.com/2024/09/15/pAu2vOP.md.png)](https://imgse.com/i/pAu2vOP)

## StateMachine
- 对于任何类型 [ where T : class , new() ] 可使用如下代码创建线性过渡
- 例如对一个100×100的Grid执行以下过渡
\`\`\`csharp
        private RotateTransform rotateTransform = new RotateTransform(-280, 50, 50);
        private TranslateTransform translateTransform = new TranslateTransform(-100, -50);
        private ScaleTransform scaleTransform = new ScaleTransform(2, 2, 50, 50);

        private void GD_MouseEnter(object sender, System.Windows.Input.MouseEventArgs e)
        {
            GD.Transition()
                .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
                .SetProperty(x => x.Opacity, 0.2)
                .SetProperty(x => x.CornerRadius,new CornerRadius(15))
                .SetParams((x) =>
                {
                    x.Duration = 0.4;
                    x.Completed = () =>
                    {
                        Notification.Message("过渡完成 √");
                    };
                })
                .Start();
        }
\`\`\`
- 但默认可用状态机过渡的属性终究是有限类型,如何让自定义的类型也能支持状态机呢?
  - 步骤1.实现一个Class1，它是支持状态机过渡的自定义类型
    - 这里Class1是Thickness和CornerRadius的复合
    - 需要实现接口方法Interpolate（）, steps是插值数量 , 你需要自定义如何将两个 Class1 拆成steps份均匀的插值
    \`\`\`csharp
    public class Class1 : ILinearInterpolation
    {
        public object Current { get; set; }
        public List<object?> Interpolate(object? current, object? target, int steps)
        {
            List<object?> result = new List<object?>();

            var v1 = current as Class1 ?? new Class1();
            var v2 = target as Class1 ?? new Class1();
            var itemsA = ILinearInterpolation.CornerRadiusComputing(v1.CornerRadius, v2.CornerRadius, steps);
            var itemsB = ILinearInterpolation.ThicknessComputing(v1.Thickness, v2.Thickness, steps);
            for (var i = 0; i < itemsA.Count; i++)
            {
                var temp = new Class1();
                temp.CornerRadius = itemsA[i] as CornerRadius? ?? new CornerRadius();
                temp.Thickness = itemsB[i] as Thickness? ?? new Thickness();
                result.Add(temp);
            }

            return result;
        }


        public Class1() { Current = this; }
        public Class1(CornerRadius cornerRadius, Thickness thickness) { Current = this; CornerRadius = cornerRadius; Thickness = thickness; }
        public CornerRadius CornerRadius { get; set; } = new CornerRadius();
        public Thickness Thickness { get; set; } = new Thickness();
    }
    \`\`\`
  - 步骤2.实现一个Class2，它是包含Class1属性的类型,是实际需要使用状态机的类型
    \`\`\`csharp
    public class Class2
    {
        public Class2() { }
       
        public Class1 Class1 { get; set; } = new Class1();

        //…… 其它属性
    }
    \`\`\`
  - 步骤3.到这一步，你已可以对Class2.Class1应用状态机的过渡功能
    \`\`\`csharp
       Class1 T1 = new Class1();
       Class1 T2 = new Class1(new CornerRadius(10), new Thickness(2, 3, 1, 0));
  
       Class2 TargetClass2 = new Class2();
  
       TargetClass2.Transition()
           .SetProperty(x => x.Class1, T2)
           .SetParams((x) =>
           {
               x.Duration = 2;
               x.Start = () =>
               {
                    Notification.Message($"旧的 Thickness {TargetClass2.Class1.Thickness}\n" +
                            $"旧的 CornerRadius {TargetClass2.Class1.CornerRadius}");
               };
               x.Completed = () =>
               {
                    Notification.Message($"新的 Thickness {TargetClass2.Class1.Thickness}\n" +
                            $"新的 CornerRadius {TargetClass2.Class1.CornerRadius}");
               };
           })
           .Start();
    \`\`\`
---
## TransitionParams 
- 包含系列参数用于修饰此次过渡效果的细节
  - 过渡效果相关的参数
  - 过渡创建相关的参数
  - 生命周期相关的参数

|属性|类型|默认|意义|
|--------|-----|-------|-------|
|Duration|double|0|动画持续时间 ( 单位: s )|
|Start|Action|null|在动画开始前执行一次|
|Update|Action|null|在动画的每一帧开始前执行一次|
|LateUpdate|Action|null|在动画的每一帧结束后执行一次|
|Completed|Action|null|在动画结束后执行一次|
|IsQueue|bool|false|新启用的动画是否排队,不排队就意味着会打断正在执行的动画|
|IsLast|bool|false|是否为最后一个被执行的动画,如果是则意味着会清空正在排队中的动画|
|IsUnique|bool|true|如果存在一个指向同一State的过渡动画,是否还要继续执行此动画|
|FrameRate|int|165|动画帧率|
|WaitTime|double|0.008|基本用不到,但如果发现有些地方概率无法触发动画或者概率抽搐,则可适当增加这个值|
|Acceleration|double|0|加速度,使得每一帧的等待时间在平面图中呈现出斜率为Acceleration的直线|

- 应用场景
  - 为StateVector设置过渡参数 ( Lambda )
  - 为Transition()设置过渡参数 ( Lambda )

\`\`\`csharp
Set((x)=>
{
    x.Duration = 0.1;
    x.IsLast = true;
    x.Update = () =>
    {
        Notification.Message("一帧开始前");
    };
})
\`\`\`
---
## State & StateVector & IConditionalTransition
- State描述某一时刻对象的属性值
- StateVector描述在何种条件下创建何种过渡
- IConditionalTransition接口允许在实例对象达成指定条件时自动创建过渡
  - 示例
    - 鼠标进入控件时,令其背景透明度过渡为0.2
    - 鼠标离开控件时,令其背景透明度过渡为0
    - Xaml - View
    \`\`\`xml
    <UserControl.DataContext>
        <local:MButtonViewModel x:Name="ViewModel"/>
    </UserControl.DataContext>
    \`\`\`
    - C# - View
    \`\`\`csharp
    public partial class MButton : UserControl
    {
        public MButton()
        {
            InitializeComponent();
            this.StateMachineLoading(ViewModel);
        }
    }
    \`\`\`
    - C# - ViewModel
    \`\`\`csharp
    public class MButtonViewModel : ViewModelBase<MButtonViewModel, MButtonModel>
    {
        public MButtonViewModel() { }

        public static State Start = State.FromObject(new MButtonViewModel())
            .SetName("defualt")
            .SetProperty(x => x.HoverBackgroundOpacity, 0)
            .ToState();
        public static State MouseIn = State.FromObject(new MButtonViewModel())
            .SetName("mouseInside")
            .SetProperty(x => x.HoverBackgroundOpacity, 0.2)
            .ToState();

        public StateVector<MButtonViewModel> Condition { get; set; } = StateVector<MButtonViewModel>.Create()
            .AddCondition(x => x.IsMouseInside, MouseIn, (x) => { x.Duration = 0.2; })
            .AddCondition(x => !x.IsMouseInside, Start, (x) => { x.Duration = 0.2; });

        public override bool IsMouseInside
        {
            get => base.IsMouseInside;
            set
            {
                base.IsMouseInside = value;
  
                OnConditionsChecked();
                //鼠标进出控件时修改IsMouseInside
                //IsMouseInside被修改时检查是否满足条件,若满足,则切换State
            }
        }
    }
    \`\`\`

---
---

# 扩展方法
## string
- 值转换
\`\`\`csharp
   string valueA = "-123.7";
   string valueB = "TrUE";
   string valueC = "#1e1e1e";
   //三个待被转换的值
   
   var result1 = valueA.ToInt();
   var result2 = valueA.ToDouble();
   var result3 = valueA.ToFloat();
   //转换成数字

   var result4 = valueB.ToBool();
   //转换成bool

   var result5 = valueC.ToBrush();
   //转换成Brush
\`\`\`
- 模糊匹配
\`\`\`csharp
   string template = "abcdefg";
   //这是待匹配的字符串

   string sourceA = "abc";
   List<string> sourceB = new List<string>()
   {
       "abcdegf",
       "cbdgafe"
   };
   //这是匹配源

   var similarity1 = sourceA.LevenshteinDistance(template)
   //返回最短编辑距离

   var similarity2 = sourceA.JaroWinklerDistance(template)
   //返回近似度

   var result3 = template.BestMatch(sourceB, 3);
   //编辑距离小于3且最小的结果

   var result4 = template.BestMatch(sourceB, 0.5);
   //近似度大于0.5且最大的结果
\`\`\`
- 文件夹生成操作
\`\`\`csharp
   string folderNameA = "FF1";
   string folderNameB = "FF2";
   string folderNameC = "FF3";
   //文件夹的名字

   var result1 = folderNameA.CreatFolder();
   //从.exe位置开始,创建名为"FF1"的文件夹

   var result2 = folderNameC.CreatFolder(folderNameA,folderNameB);
   //从.exe位置开始,创建名为"FF1/FF2/FF3"的文件夹
\`\`\`
- Xml 和 Json 序列化
\`\`\`csharp
   string folderName = "Data";
   //假设文件需要放在Data文件夹内

   string fileName1 = "firstPersondata";
   string fileName2 = "secondPersondata";
   //假设这是两份文件的文件名

   var target = new Person();
   //假设需要将一个Person实例序列化存储

   var result1 = fileName1.CreatXmlFile(folderName.CreatFolder(), target);
   var result2 = fileName2.CreatJsonFile(folderName.CreatFolder(), target);
   //分别存储为.xml和.json文件
\`\`\`
- Xml 和 Json 反序列化
\`\`\`csharp
   string folderName = "Data";

   string fileName1 = "firstPersondata";
   string fileName2 = "secondPersondata";

   string AbsPathA = Path.Combine(folderName.CreatFolder(), $"{fileName1}.xml");
   string AbsPathB = Path.Combine(folderName.CreatFolder(), $"{fileName2}.json");
   var dataA = File.ReadAllText(AbsPathA);
   var dataB = File.ReadAllText(AbsPathB);
   //拿到原始数据

   var result1 = dataA.XmlParse<Person>();
   var result2 = dataB.JsonParse<Person>();
   //反序列化
\`\`\`
- 正则操作
\`\`\`csharp
   string sourceA = "[1]wkhdkjhk[a][F3]https:awijdioj.mp3fwafw";
   string sourceB = "awdhttps://aiowdjoajfo.comawd&*(&d)*dhttps://tn.comdawd";
   //原始数据
   
   var resultA = sourceA.CaptureBetween("https:", ".mp3");
   //捕获所有包含在"https:"和".mp3"中间的字符串

   var resultB = sourceB.CaptureLike("https://", "com");
   //捕获所有符合先出现"https://"再出现"com"特征的字符串,特征可以是多个
\`\`\`
- 密码强度
\`\`\`csharp
   string password = "12345678";
   int Level = password.CheckPasswordStrength(MinLength=8);
   //返回0~4的整数代表密码强度
\`\`\`

---
---

# 用户控件
- ## ☆ Using
  - C#
    \`\`\`csharp
    using MinimalisticWPF;
    \`\`\`
  - XAML
    \`\`\`xml
    xmlns:mn="clr-namespace:MinimalisticWPF;assembly=MinimalisticWPF"
    \`\`\`
  - 不使用Width/Height调整大小,而是带有Wise、Size字样的属性,最后通过Margin调整位置
  - 需要使用例如"#1e1e1e"的深色背景板,很多控件都是白边透明底的,浅色背景板效果不佳
- ## ☆ MButton
  ![Effect](https://s21.ax1x.com/2024/09/09/pAeLPyQ.png)
  ## Property
  - Click
  - WiseHeight
  - WiseWidth
  - Text
  - TextBrush
  - FontSizeRatio
  - EdgeBrush
  - EdgeThickness
  - HoverBrush
  - CornerRadius
---
- ## ☆ MTopBar
  ![pAmMfv8.md.png](https://s21.ax1x.com/2024/09/09/pAmMfv8.md.png)
  ![pAmQnVH.md.png](https://s21.ax1x.com/2024/09/09/pAmQnVH.md.png)
  ## Property
  - WiseHeight
  - WiseWidth
  - Title
  - SizeRatio
  - EdgeBrush
  - EdgeThickness
  - HoverBrush
  - CornerRadius
  - Icon
---
- ## ☆ MPasswordBox
  ![Effect](https://s21.ax1x.com/2024/09/09/pAeLEoq.png)
  ![Effect](https://s21.ax1x.com/2024/09/09/pAeLQOJ.png)
  ## Property
  - WiseHeight
  - WiseWidth
  - FontSizeRatio
  - Password
  - Replace
---
- ### ☆ MProgressBar
  ![Effect](https://s21.ax1x.com/2024/09/09/pAeLkes.png)
  ## Property
  - Size
  - Value
  - Shape
  - Thickness
  - BottomBrush
  - FillBrush
  - TextBrush
  - FontSizeRatio
  - IsReverse
  - StartAngle
  - EndAngle
---
- ### ☆ Notification
  [![pAKM40S.png](https://s21.ax1x.com/2024/09/18/pAKM40S.png)](https://imgse.com/i/pAKM40S)
  [![pAKMhm8.png](https://s21.ax1x.com/2024/09/18/pAKMhm8.png)](https://imgse.com/i/pAKMhm8)
  ## 消息框调用示例
  \`\`\`csharp
            if (Notification.Select("Are you sure you want to check the weather ?"))
            {
                Notification.Message("Weather");
            }
  \`\`\`

---
---

# Web服务
- ## 高德
  - using
    \`\`\`csharp
    using MinimalisticWPF.GaoDeServices;
    \`\`\`
  - 前往获取ApiKey https://console.amap.com/dev/key/app
    \`\`\`csharp
        protected override void OnSourceInitialized(EventArgs e)
        {
            base.OnSourceInitialized(e);

            GaoDeAPISet.Awake(Key: "Your_Api_Key", IsUpdateIP: true);
            //[ IsUpdateIP ] 描述本次加载是否要重新读取IP信息
        }
    \`\`\`
  - IPService
    - 获取当前IP
      \`\`\`csharp
      var ip = await IPService.GetIP();
      MessageBox.Show(ip.GetCombined());
      \`\`\`
    - 依据地区名称获取行政编码
      \`\`\`csharp
      var adcode = await IPService.GetAdCode("都江堰");
      MessageBox.Show(adcode);
      \`\`\`
  - WeatherService
    - 依据当前IP获取天气
      \`\`\`csharp
      var weathers = await WeatherService.GetWeathers();
      MessageBox.Show(weathers[0].GetCombined());
      \`\`\`
    - 依据地区名称获取天气
      \`\`\`csharp
      var weathers = await WeatherService.GetWeathers("都江堰");
      MessageBox.Show(weathers[0].GetCombined());
      \`\`\`
    - weather[0] 代表今天的天气
                    `;
    
                    // 使用 marked.js 转换 Markdown 内容
                    this.renderedMarkdown = marked(markdownContent);
                }
            });
        </script>
    </div>

    <!--代码框创建-->
    <script>
        //文本+容器ID
        function createCodeBox(code, id) {
            // 创建代码容器
            const container = document.createElement('div');
            container.className = 'code-container';

            // 创建复制按钮
            const button = document.createElement('button');
            button.className = 'copy-button';
            button.innerText = '复制';
            button.onclick = () => copyToClipboard(code);

            // 创建预格式代码块
            const pre = document.createElement('pre');
            const codeElement = document.createElement('code');
            codeElement.innerText = code;
            pre.appendChild(codeElement);

            // 将按钮和代码块添加到容器中
            container.appendChild(button);
            container.appendChild(pre);

            // 将代码容器添加到页面上
            document.getElementById(id).appendChild(container);
        }

        function copyToClipboard(code) {
            // 创建临时文本域
            const tempInput = document.createElement('textarea');
            tempInput.value = code;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            alert('复制成功！');
        }

        // 在页面加载时创建多个代码框
        window.onload = function () {
            createCodeBox(`private static State State1 = State.FromType<Grid>()
    .SetName("TransformChange")
    .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
    .SetProperty(x => x.Background, Brushes.Tomato)
    .ToState();`, "18x_FromType");
            createCodeBox(`private static State State2 = State.FromObject(new Grid())
    .SetName("OpacityChange")
    .SetProperty(x => x.RenderTransform, rotateTransform2, translateTransform2, scaleTransform2)
    .SetProperty(x => x.Background, Brushes.Cyan)
    .ToState();`, "18x_FromObject");
        };
        createCodeBox(`//描述过渡（动画）效果的细节参数
private static Action<TransitionParams> TP1 = (x) =>
{
    x.IsUnSafe = false;
    x.Duration = 2;
    x.Acceleration = -1;
};

//GD是一个类型实例，此处为Grid控件实例，你可用如下方法使其加载动画，最终使其RenderTransform与Background变为你所记录的目标值（State1中）
private void OnClick1(object sender, System.Windows.Input.MouseButtonEventArgs e)
{
    GD.BeginTransition(State1, TP1);
}`, "18x_StateBegin");
createCodeBox(`//ViewModelBase已经实现了IConditionalTransition接口
public class MButtonViewModel : ViewModelBase<MButtonViewModel, MButtonModel>
{
    public MButtonViewModel() { }

    public static State Start = State.FromObject(new MButtonViewModel())
        .SetName("default")
        .SetProperty(x => x.HoverBackgroundOpacity, 0)
        .ToState();
    public static State MouseIn = State.FromType<MButtonViewModel>()
        .SetName("mouseInside")
        .SetProperty(x => x.HoverBackgroundOpacity, 0.2)
        .ToState();

    public StateVector<MButtonViewModel> ConditionA { get; set; } = StateVector<MButtonViewModel>.Create()
        .AddCondition(x => x.IsMouseInside, MouseIn, (x) => { x.Duration = 0.2; })
        .AddCondition(x => !x.IsMouseInside, Start, (x) => { x.Duration = 0.2; });

    public override bool IsMouseInside
    {
        get => base.IsMouseInside;
        set
        {
            base.IsMouseInside = value;
            OnConditionsChecked();
            //IConditionalTransition接口提供的方法，使得你可在属性变动时，检测当前ViewModel是否满足预先定义的条件判断语句
            //如果满足x.IsMouseInside,则过渡至MouseIn
            //如果满足!x.IsMouseInside,则过渡至Start
        }
    }
}`,"18x_StateVectorViewModel");
createCodeBox(`public MButton()
{
    InitializeComponent();
    this.StateMachineLoading(ViewModel);
}
    //这是所有FrameworkElement所具备的状态机加载方法,ViewModel是MButton的DataContext,我这里直接命名为ViewModel比较方便
    //注意ViewModel必须实现IConditionalTransition接口，否则是无法用这种方式加载状态机以支持【条件切换】功能的`,"18x_StateVectorView");
    createCodeBox(`//先把平移、旋转、缩放动画单独拎出来
private RotateTransform rotateTransform = new RotateTransform(-280, 50, 50);
private TranslateTransform translateTransform = new TranslateTransform(-100, -50);
private ScaleTransform scaleTransform = new ScaleTransform(2, 2, 50, 50);

private void GD_MouseEnter(object sender, System.Windows.Input.MouseEventArgs e)
{
    //凡SetProperty描写过的属性,本次动画都会应用到,这里相当于同时加载了5个动画效果
    GD.Transition()
        .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
        .SetProperty(x => x.Opacity, 0.2)
        .SetProperty(x => x.CornerRadius,new CornerRadius(15))
        .SetParams((x) =>
        {
            x.Duration = 0.4;

            //动画结束时执行
            x.Completed = () =>
            {
                //类库提供的模态窗口
                Notification.Message("动画完成 √");
            };
        })
        .Start();
}`,"18x_GDAnimation");
    </script>
</body>

</html>