<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/2.0.0/marked.min.js"></script>
</head>

<!--代码框样式-->
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #595757;
    }

    .code-container {
        position: relative;
        background-color: #282c34;
        color: #fff;
        border-radius: 5px;
        border: 1px solid white;
        padding: 5px;
        margin-bottom: 0px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .copy-button {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #61dafb;
        border: none;
        color: #282c34;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
    }
</style>

<!--版本选择框样式-->
<style>
    /* 自定义选择框样式 */
    .custom-select {
        color: rgb(88, 222, 255);
        /* 文字颜色 */
        background-color: #363333;
        /* 背景颜色 */
        padding: 5px;
        /* 内边距 */
        border-radius: 5px;
        /* 圆角 */
        cursor: pointer;
        /* 鼠标指针样式 */
        margin-left: 0%;
        width: 120px;
        text-align: center;
        transition: background-color 0.3s, color 0.3s;
        /* 过渡效果 */
    }

    option {
        text-align: center;
    }

    .custom-select:hover {
        background-color: #95d4de7a;
    }

    .custom-select:focus {
        background-color: #444;
    }
</style>

<!--整体布局样式-->
<style>
    header {
        background: #363333;
        color: white;
        padding: 10px 0;
        text-align: center;
        border-radius: 10px;
    }

    h1 {
        color: #00fff2;
    }

    h2 {
        color: aquamarine;
    }

    h3 {
        color: rgb(246, 249, 167);
    }

    div {
        border-radius: 10px;
        overflow-y: auto;
    }

    .container {
        display: flex;
        height: calc(100vh - 60px);
    }

    nav {
        width: 200px;
        background-color: #444343;
        padding: 15px;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        border-radius: 10px;
    }

    nav button {
        padding: 5px;
        color: rgb(101, 250, 163);
        text-align: left;
        margin: 5px 0;
        border-radius: 5px;
        background-color: transparent;
        width: 100%;
        font-size: 20px;
    }

    nav button:hover {
        background-color: #ffffff51;
    }

    .content {
        flex-grow: 1;
        padding: 15px;
        background-color: #444343;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
    }
</style>

<!--MarkDown样式-->
<style>
    th,
    td {
        color: white;
        border: 1px solid white;
    }

    p,
    li,
    code,
    summary {
        color: white;
        overflow-x: auto;
    }

    img {
        overflow-x: auto;
    }
</style>

<body>
    <div id="app">
        <header>
            <h1>MinimalisticWPF</h1>
            <p style="color: aquamarine;">探索简洁、清晰、易于管理的WPF动画实现方案</p>
            <section>
                <select v-model="Version" class="custom-select">
                    <option value="1.5.x">V1.5.x</option>
                    <option value="1.8.x">V1.8.x</option>
                </select>
                <div v-html="renderedMarkdown"></div>
            </section>
        </header>

        <!--V1.8.x-->
        <div v-show="Version==='1.8.x'">
            <div class="container">
                <nav>
                    <h1>目录</h1>
                    <button @Click="a1Click">Ⅰ 简介</button>
                    <button @Click="a2Click">Ⅱ 入门</button>
                    <button @Click="a3Click">Ⅲ State</button>
                    <button @Click="a4Click">Ⅳ StateVector</button>
                    <button @Click="a5Click">Ⅴ 生命周期</button>
                    <button @Click="a6Click">Ⅵ UnSafe机制</button>
                    <button @Click="a7Click">Ⅶ 最佳实践</button>
                    <button @Click="a8Click">Ⅷ 接口</button>
                    <button @Click="a9Click">Ⅸ 更多</button>
                </nav>
                <div class="content">
                    <div v-show="Area==='1'">
                        <h1>简介</h1>
                        <h2>1.MinimalisticWPF是什么?</h2>
                        <h3>MinimalisticWPF是一个可用于创建、修改WPF动画的类库</h3>
                        <p>它允许你直接创建对于对象属性的平滑过渡效果,这是动画效果能够实现的核心思路</p>
                        <p>同时,它在MVVM设计模式中,可以像Unity等游戏引擎中的状态机一样,通过预先设定一些 [ 条件 => 动画 ] 对照关系,可以自动修改ViewModel属性值从而实现动画效果</p>
                        <h2>2.MinimalisticWPF的优点?</h2>
                        <h3>(1)以更少的代码量实现动画</h3>
                        <p>纯粹的C#写法,适合喜欢写后端的人员</p>
                        <p>不需要关注DependencyProperty,只要一个属性的get器和set器都可访问且其类型受到类库支持,那都是可以直接为这个属性创建过渡的</p>
                        <p>对于任何类型AnyClass的实例对象都可以用 [ AnyClass.Transition() ] [ AnyClass.BeginTransition() ] 来创建属性值的过渡效果
                        </p>
                        <h3>(2)以更清晰、灵活的方式实现动画</h3>
                        <h3>(3)以更轻松的方式管理每一帧</h3>
                        <h2>3.MinimalisticWPF的缺点？</h2>
                        <h3>(1)它的性能大概率低于storyboard、visualtstate</h3>
                        <h3>(2)它难以实现在时间维度拥有复杂变化的动画(暂时)</h3>
                        <h3>(3)……</h3>
                        <h2>4.为什么选择MinimalisticWPF?</h2>
                        <h3>(1)写起来方便</h3>
                        <p>这是最关键的因素</p>
                        <p>实际上,写这个项目只是觉得不喜欢WPF动画那套写法</p>
                        <p>而且,依赖属性这个东西想要随时随地获取并不算容易,那我不如将精力完全放在 [ 属性 ] 本身的过渡</p>
                        <h3>(2)MVVM模式支持</h3>
                        <p>又是个人习惯问题</p>
                        <p>我喜欢XAML内只负责布局与数据绑定、Model负责数据、DataContext负责剩下的，这个才是MinimalisticWPF功效最大化的使用场景</p>
                        <p>不过不这么用也行的,动画全放Code-Behind而不是DataContext,一样可以受到类库带来的便利</p>
                    </div>
                    <div v-show="Area==='2'">
                        <h1>入门</h1>
                        <h2>1.创建你的第一个动画效果</h2>
                        <h3>以一个Grid控件为例，创建持续2s的动画</h3>
                        <p>效果:</p>
                        <p>1.透明度变为0.3</p>
                        <p>2.宽度和高度均变为200</p>
                        <div id="cd2-1"></div>
                        <h2>2.使用TransitionBoard绘板实现动画效果复用</h2>
                        <p>为Grid类创建一个通用的TransitionBoard绘板</p>
                        <div id="cd2-2"></div>
                        <p>Grid实例可以直接用TransitionBoard绘板启动动画</p>
                        <div id="cd2-3"></div>
                        <h2>3.使用State绘板实现动画效果复用</h2>
                        <p>为Grid类创建一个通用的State绘板</p>
                        <div id="cd2-4"></div>
                        <p>Grid实例可以直接用State绘板启动动画</p>
                        <div id="cd2-5"></div>
                        <p>tips:</p>
                        <p>State必须拥有Name</p>
                        <p>State作为绘板使用时,需要在动画启动时传入一次参数</p>
                        <h2 style="color: rgb(75, 228, 225);">现在,你已熟悉该库最为常见的使用场景！</h2>
                        <h3 style="color: rgb(255, 255, 255);">接下来的建议:</h3>
                        <h3 style="color: rgb(255, 255, 255);">1.State和StateVector - 允许像Unity状态机那样,使用条件连接并自动执行动画</h3>
                        <h3 style="color: rgb(255, 255, 255);">2.生命周期 - 丰富动画的执行过程</h3>
                        <h3 style="color: rgb(255, 255, 255);">3.UnSafe机制 - 像搭积木那样实现动画</h3>
                        <h3 style="color: rgb(255, 255, 255);">4.最佳实践 - 完全后端的动画实现方案</h3>
                        <h3 style="color: rgb(255, 255, 255);">5.接口 - 更多可能性的支持</h3>
                    </div>
                    <div v-show="Area==='3'">
                        <h1>State</h1>
                        <h2>1.State是什么?</h2>
                        <p>一个类型,用于描述对象在某个时刻的属性值,也就是这个对象在某一时刻的 [ 状态 ]</p>
                        <h2>2.消耗少量性能,记录一个对象在某一时刻的状态 Type-based</h2>
                        <p>(1)记录过程不涉及额外的反射、遍历操作</p>
                        <p>(2)只能记录指定的属性</p>
                        <div id="cd3-1"></div>
                        <h2>3.消耗大量性能,但允许你自动记录对象所有受支持的属性值 Object-based</h2>
                        <p>(1)⚠ 记录过程包括大量反射、遍历操作</p>
                        <p>(2)可以通过ToState(false)表明记录所有受支持的属性,而不局限于手动指定过的属性</p>
                        <div id="cd3-2"></div>
                        <h2>4.记录的状态可以用来干什么?</h2>
                        <h3>(1)启动动画,这在 [ 入门 ] 已经演示过</h3>
                        <h3>(2)☆ 与 <button style="color: lime;background-color:transparent"
                                @Click="a4Click">StateVecotr</button> 结合使用</h3>
                    </div>
                    <div v-show="Area==='4'">
                        <h1>StateVector</h1>
                        <h2>1.StateVector是什么?</h2>
                        <p>假设有一个实例对象Instance和一个State实例,你希望Instance满足条件Condition时,自动将Instance切换为State记录的状态,这个过程会是个自动生成的平滑动画,StateVector描述了这种
                            [ 条件 → 状态 ] 的连接关系</p>
                        <h2>2.如何定义它?</h2>
                        <p>设立两个区间,Grid.Width在进入到区间时可以自动过渡到对应的状态</p>
                        <p>注意:</p>
                        <p>(1)实际使用中,条件一般是更为严谨的</p>
                        <p>(2)若要使得这种自动生成动画生效,需要实现IConditionalTransition接口</p>
                        <p>(3)具体实现请参阅 <button style="color: lime;background-color:transparent"
                                @Click="a7Click">最佳实践</button></p>
                        <div id="cd4-1"></div>
                    </div>
                    <div v-show="Area==='5'">
                        <h1>生命周期</h1>
                        <h2>阶段:</h2>
                        <h3>Start - 动画开始前执行一次</h3>
                        <h3>Update - 动画每帧执行一次</h3>
                        <h3>LateUpdate - 动画每帧结束后执行一次</h3>
                        <h3>Completed - 动画结束时执行一次</h3>
                        <h2>定义:</h2>
                        <h3>单独定义委托</h3>
                        <div id="cd5-1"></div>
                        <h3>在函数参数传入Lambda</h3>
                        <div id="cd5-2"></div>
                    </div>
                    <div v-show="Area==='6'">
                        <h1>UnSafe机制</h1>
                        <h2>1.为什么会存在Unsafe机制?</h2>
                        <h3>相对于Safe而言:</h3>
                        <p>(1)无条件开始执行动画效果</p>
                        <p>(2)过程不可被打断</p>
                        <h3>用处:</h3>
                        <p>将复杂动画拆解为一个一个的 [ 分量 ] , 例如多个Grid都拥有动画效果 , 但很多效果都是相同的 , 只有那么一小块存在差异 ，这时就可以将小块差异独立拆解为 [ 分量A ]
                            ，相同部分记录为 [ 分量B ] ，那么每个Grid实例在开始动画前 , 都可以修改实例的 [ 分量A ] , 而静态的 [ 分量B ]不变，最终，同时执行 [ 分量A ]与[ 分量B
                            ] 就能使得每个Grid既有共同点，也有差异点 </p>
                        <p>也就是说,全局只需要一个static的[ 分量B ]和若干非static的[ 分量A ]就足够了,只需要启动动画前依据条件修改[ 分量A ],那么每个实例都可拥有独立的动画效果 </p>
                        <h2>2.实战案例</h2>
                        <h3>首先,做个需求分析</h3>
                        <p>以两个Grid控件为例:</p>
                        <p>共同点:宽度和高度都变为100(Safe)</p>
                        <p>差异化:GD1透明度变为0.8；GD2透明度变为0.3(UnSafe)</p>
                        <h3>开始定义UnSafe动画与Safe动画</h3>
                        <div id="cd6-1"></div>
                        <h3>启动!</h3>
                        <p>注意:</p>
                        <p>BeginTransition方法一定会打断Safe动画,因此Unsafe需要在Safe前启动</p>
                        <div id="cd6-2"></div>
                    </div>
                    <div v-show="Area==='7'">
                        <h1>最佳实践</h1>
                        <h2>MVVM模式下,实现一个密码框,其边框颜色会依据密码强度做出变化</h2>
                        <h3>回顾: State与StateVector</h3>
                        <p>1.思路拆解:</p>
                        <p>(1)需要1个State表示密码长度不符合时的边框颜色状态</p>
                        <p>(2)密码强度分1~4,所以又需要4个State表示对应状态下的边框颜色</p>
                        <p>(3)需要一个StateVector来描述 [ 条件 → State ] 关系</p>
                        <p>(4)每次密码改变时,应当唤醒StateVector去做条件判断</p>
                        <h3>2.DataContext代码实现</h3>
                        <p>密码框的颜色绑定为 [ PasswordStrengthColor属性 ]</p>
                        <p>密码改变时,其Set器内需要调用 [ OnConditionsChecked() ]以唤醒StateVector </p>
                        <div id="cd7-1"></div>
                        <h3>3.DataContext实现完毕后,需要在Code-Behind激活状态机</h3>
                        <p>这个方法只有FrameworkElement可用</p>
                        <div id="cd7-2"></div>
                        <p>DataContext建议在XAML内定义</p>
                        <div id="cd7-4"></div>
                        <h3>4.ViewModel为什么可以拥有OnConditionsChecked()</h3>
                        <p>因为ViewModelBase继承了StateViewModelBase,而StateViewModelBase实现了一些必要的接口</p>
                        <p>(1)INotifyPropertyChanged - 这个我想无需多言,用过MVVM都懂</p>
                        <p>(2)IConditionalTransition - 这个接口是你可以用 [ this.StateMachineLoading(ViewModel) ] 激活条件切换功能的关键组件</p>
                        <p>(3)这里是它的定义,几乎是MVVM下最小实现单元</p>
                        <div id="cd7-3"></div>                    
                    </div>
                    <div v-show="Area==='8'">
                        <h1>接口</h1>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                    <div v-show="Area==='9'">
                        <h1>更多</h1>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
            </div>
        </div>

        <!--V1.5.x-->
        <div v-show="Version === '1.5.x'">
            <h2>中文文档 V{{ Version }}</h2>
            <div style="background-color: #444;" v-html="Markdown"></div>
        </div>
    </div>
</body>

<!--代码框创建-->
<script>
    //文本+容器ID
    function createCodeBox(code, id) {
        // 创建代码容器
        const container = document.createElement('div');
        container.className = 'code-container';

        // 创建复制按钮
        const button = document.createElement('button');
        button.className = 'copy-button';
        button.innerText = '复制';
        button.onclick = () => copyToClipboard(code);

        // 创建预格式代码块
        const pre = document.createElement('pre');
        const codeElement = document.createElement('code');
        codeElement.innerText = code;
        pre.appendChild(codeElement);

        // 将按钮和代码块添加到容器中
        container.appendChild(button);
        container.appendChild(pre);

        // 将代码容器添加到页面上
        document.getElementById(id).appendChild(container);
    }

    function copyToClipboard(code) {
        // 创建临时文本域
        const tempInput = document.createElement('textarea');
        tempInput.value = code;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
        alert('复制成功！');
    }
</script>

<!--Vue实例-->
<script>
    new Vue({
        el: '#app',
        methods: {
            a1Click() {
                this.Area = '1';
            },
            a2Click() {
                this.Area = '2';
            },
            a3Click() {
                this.Area = '3';
            },
            a4Click() {
                this.Area = '4';
            },
            a5Click() {
                this.Area = '5';
            },
            a6Click() {
                this.Area = '6';
            },
            a7Click() {
                this.Area = '7';
            },
            a8Click() {
                this.Area = '8';
            },
            a9Click() {
                this.Area = '9';
            }
        },
        data: {
            Version: '1.8.x',
            Area: '1',
            MarkDown: '',
        },
        mounted() {
            //代码框
            window.onload = function () {
                createCodeBox(`GD.Transition()
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .SetParams((x) =>
    {
        x.Duration = 2;
    })
    .Start();`, 'cd2-1');
                createCodeBox(`TransitionBoard<Grid> _board = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .SetParams((x) =>
    {
        x.Duration = 2;
    });`, 'cd2-2');
                createCodeBox(`GD.BeginTransition(_board);`, 'cd2-3');
                createCodeBox(`State _board = State.FromType<Grid>()
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState();

Action<TransitionParams> _params = (x) =>
{
    x.Duration = 2;
};`, 'cd2-4');
                createCodeBox(`GD.BeginTransition(_board, _params);`, 'cd2-5');
                createCodeBox(`State _board = State.FromType<Grid>()
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState();`, 'cd3-1');
                createCodeBox(`State _board = State.FromObject(new Grid())
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState(false);`, 'cd3-2');
                createCodeBox(`static State _board1 = State.FromType<Grid>()
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState();
static State _board2 = State.FromType<Grid>()
    .SetName("Animation2")
    .SetProperty(x => x.Opacity, 1)
    .SetProperty(x => x.Width, 100)
    .SetProperty(x => x.Height, 100)
    .ToState();

StateVector<Grid> _vector = StateVector<Grid>.Create()
    .AddCondition(x => x.Width > 10 && x.Width <= 20, _board1, (x) => { x.Duration = 0.2; })
    .AddCondition(x => x.Width > 20 && x.Width <= 100, _board2, (x) => { x.Duration = 0.2; });`, 'cd4-1');
                createCodeBox(`Action<TransitionParams> _params = (x) =>
{
    x.Duration = 2;
    x.Start = () =>
    {

    };
    x.Update = () =>
    {

    };
    x.LateUpdate = () =>
    {

    };
    x.Completed = () =>
    {

    };
};`, 'cd5-1');
                createCodeBox(`StateVector<Grid> _vector = StateVector<Grid>.Create()
    .AddCondition(x => x.Width > 20 && x.Width <= 100, _board2,
    (x) =>
    {
        x.Duration = 0.2;
        x.Start = () =>
        {

        };
        x.Update = () =>
        {

        };
        x.LateUpdate = () =>
        {

        };
        x.Completed = () =>
        {

        };
    });`, 'cd5-2');
                createCodeBox(`static TransitionBoard<Grid> Safe = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Width, 100)
    .SetProperty(x => x.Height, 100)
    .SetParams((x) =>
    {
        x.Duration = 1;
    });
TransitionBoard<Grid> UnSafe_1 = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Opacity, 1)
    .SetParams((x) =>
    {
        x.IsUnSafe = true;
        x.Duration = 1;
    });
TransitionBoard<Grid> UnSafe_2 = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Opacity, 1)
    .SetParams((x) =>
    {
        x.IsUnSafe = true;
        x.Duration = 1;
    });`, 'cd6-1');
                createCodeBox(`if (GD1.Width > 1)
{
    UnSafe_1.SetProperty(x => x.Opacity, 0.8);
}

if (GD2.Height > 1)
{
    UnSafe_2.SetProperty(x => x.Opacity, 0.3);
}

GD1.BeginTransition(UnSafe_1);
GD2.BeginTransition(UnSafe_2);

GD1.BeginTransition(Safe);
GD2.BeginTransition(Safe);`, 'cd6-2');
                createCodeBox(`/// <summary>
/// 作为密码框的DataContext
/// </summary>
public class MPasswordBoxViewModel : ViewModelBase<MPasswordBoxViewModel, MPasswordBoxModel>
{
    public MPasswordBoxViewModel() { }

    //默认颜色
    public static State Default = State.FromType<MPasswordBoxViewModel>()
        .SetName("default")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.White)
        .ToState();

    //密码强度有四个分级，对应四个不同的颜色
    public static State Level1 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L1")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Tomato)
        .ToState();
    public static State Level2 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L2")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Yellow)
        .ToState();
    public static State Level3 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L3")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Cyan)
        .ToState();
    public static State Level4 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L4")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Lime)
        .ToState();

    //达到指定密码强度时，切换至指定的State
    public StateVector<MPasswordBoxViewModel> Condition { get; set; } = StateVector<MPasswordBoxViewModel>.Create()
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 0, Default, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 1, Level1, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 2, Level2, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 3, Level3, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 4, Level4, (x) => { x.Duration = 0.3; });

    //真实密码
    public string TruePassword
    {
        get => Model.TruePassword;
        set
        {
            Model.TruePassword = value;
            string result = string.Empty;
            for (int i = 0; i < value.Length; i++)
            {
                result += ReplacingCharacters;
            }
            UIPassword = result;
            OnPropertyChanged(nameof(TruePassword));

            OnConditionsChecked();
            //由IConditionalTransition接口规定的方法
            //StateViewModelBase是实现MVVM并且接入状态机系统【条件切换】功能的最小实现单元,它帮你实现了INotifyPropertyChanged与IConditionalTransition接口
            //调用这句话即可在密码改变时,检测密码强度并执行动画
        }
    }

    /// <summary>
    /// 用户视觉可见的密码
    /// </summary>
    public string UIPassword
    {
        get => Model.UIPassword;
        set
        {
            Model.UIPassword = value;
            OnPropertyChanged(nameof(UIPassword));
        }
    }

    /// <summary>
    /// 用于替换真实密码的字符
    /// </summary>
    public string ReplacingCharacters
    {
        get => Model.ReplacingCharacters;
        set
        {
            Model.ReplacingCharacters = value;
            string result = string.Empty;
            for (int i = 0; i < TruePassword.Length; i++)
            {
                result += ReplacingCharacters;
            }
            UIPassword = result;
            OnPropertyChanged(nameof(ReplacingCharacters));
        }
    }

    /// <summary>
    /// 密码强度对应的边框颜色
    /// </summary>
    public Brush PasswordStrengthColor
    {
        get => Model.PasswordStrengthColor;
        set
        {
            Model.PasswordStrengthColor = value;
            OnPropertyChanged(nameof(PasswordStrengthColor));
        }
    }
}`, 'cd7-1');
                createCodeBox(`public MPasswordBox()
{
    InitializeComponent();
    this.StateMachineLoading(ViewModel);
}`, 'cd7-2');
                createCodeBox(`    /// <summary>
    /// MVVM下,使ViewModel支持状态机的示例写法
    /// </summary>
    /// <typeparam name="T">ViewModel的真实类型</typeparam>
    public abstract class StateViewModelBase<T> : INotifyPropertyChanged, IConditionalTransition<T> where T : class
    {
        public event PropertyChangedEventHandler? PropertyChanged;
        public void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public T? Target { get; set; }
        public StateMachine? StateMachine { get; set; }
        public StateVector<T>? StateVector { get; set; }
        public void OnConditionsChecked()
        {
            if (Target == null)
            {
                Target = this as T ?? throw new ArgumentException($"This instance cannot be converted to an instance of type [ {nameof(T)} ]");
            }
            if (StateVector != null && StateMachine != null)
            {
                StateVector?.Check(Target, StateMachine);
            }
        }
    }`, 'cd7-3');
                createCodeBox(`<UserControl.DataContext>
    <local:MPasswordBoxViewModel x:Name="ViewModel"
                                 CornerRadius="10"
                                 FontSizeConvertRate="0.7"
                                 TextBrush="White"/>
</UserControl.DataContext>`, 'cd7-4');
                createCodeBox(``, 'cd8-1');
                createCodeBox(``, 'cd8-2');
                createCodeBox(``, 'cd8-3');
                createCodeBox(``, 'cd8-4');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
            }


            //Markdown
            const markdownContent = `
## 修改 
<details>
<summary>V1.5.0 即将弃用</summary>

- Transition() 改为支持任何 [ where T : class ,new() ] 类型
- State限制修改，需要是公开静态字段或公开属性
- StateVector限制修改，需要写作公开属性
- 支持Transform过渡
- Translate
- Scale
- Rotate
- 支持Point过渡
- 支持CornerRadius过渡
- 支持Thickness过渡
- 接口ILinearInterpolation允许自定义的类型作为可过渡属性
</details>

<details>
<summary>V1.5.1 即将弃用</summary>

- Acceleration 加速度支持
- 删除状态机运作时,部分不必要的对象生成操作 
</details>

<details>
<summary>V1.5.2 即将弃用</summary>

- 修复了NET6.0框架下动画效果异常的问题
</details>

<details>
<summary>V1.5.3 即将弃用</summary>

- State 性能优化
- 基于 Object
- 在State初始化时执行了大量反射、LINQ操作
- 允许自动化地记录一个object所有受支持的属性
- 基于 Type
- 在State初始化时不执行任何反射、LINQ操作
- 只能手动指定需要修改的属性
- 使用
- State.FromType<>() / StateMachineTransition( StateRecordModes.Type )
- State.FromObject() / StateMachineTransition( StateRecordModes.Object )
- TransitionInterpreter 逻辑优化
- 解决了频繁切换State可能导致的抽搐问题
</details>

<details>
<summary>V1.5.6</summary>

- 修复
- 帧率处于 57~61 时，渐变结果可能失真
- 帧率低于 100 时，高速切换State可能导致启动状态机失败
- 帧率为 0 时，出现错误
- 持续时间为 0 时，出现错误
- 调整
- 帧率默认值已调整为 120Hz
- 帧率限制为 1~240 ,超出范围将被自动矫正
- 新增
- class.IsSatisfy() 允许你基于实例对象是否满足指定的条件,决定是否启动预先描述的过渡
\`\`\`csharp
    var board = GD.Transition()
        .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
        .SetParams((x) =>
        {
            x.Duration = 3;
            x.Acceleration = 1;
        });

    var result = GD.IsSatisfy(x => x.Width < 1000, board, true);
    //参数1.条件(必须)
    //参数2.若满足条件,则执行此过渡(非必须)
    //参数3.过渡效果若为基于对象的,是否启用白名单机制(非必须)
\`\`\`
- 2.0.0 版本预告
- ★ 对文档进行大幅优化
- ★ 开放更多原本只可以在状态机系统内部运作的功能
- 修复更多潜在问题
- 尝试进一步优化性能   
- 增加更多常用的扩展方法
- ⚠ 移除所有非核心组件
</details>

## 核心功能
- [状态机系统 - 对指定实例的指定属性创建线性过渡](#状态机系统)
- [StateMachine 执行过渡功能的核心组件]() 
- [TransitionParams 调整过渡效果细节]()
- [MVVM 使用State与StateVector]()
- 可参与状态机过渡的属性类型
- double
- Brush
- Transform      
- CornerRadius
- Thickness
- Point
- ★ ILinearInterpolation ( 该接口使得任意自定义类型支持状态机过渡 )
## 辅助功能
- [扩展方法](#扩展方法)
- [string]
- 值转换
- 模糊匹配
- 分析工具（例如提取html中的资源地址）
- 密码强度
- [用户控件](#用户控件)
- 统一的深色主题
- 字体大小自适应控件高度
- 所有动画效果都基于状态机系统,它们既是直接可用的,也是状态机系统的实践
- Notification - 玻璃风格的通知/选择框
- MProgressBar - 条状/环状自由切换的进度条
- MTopBar - 程序顶侧栏
## 非核心组件
###### MinimalisticWPF命名空间不包括下述服务，另需引用
- [Web服务](#Web服务)
- [ 高德 ] WebApi
- IP服务
- 天气服务

## 支持框架
- [.NET6.0-windows] 
- [.NET8.0-windows]
## 获取
- [github][1]
- [nuget][2]

[1]: https://github.com/ChengduNeusoftUniversity-FengJunjie-Y22/MinimalisticWPF
[2]: https://www.nuget.org/packages/MinimalisticWPF/

---

# 状态机系统
- State & StateVecotr 为MVVM而生 ,可通过预先设置条件实现状态的自动切换
- StateMachine 理论可对任何类型的属性做出线性过渡，非MVVM下，几乎所有类型都包含一个用于快速为对象实例创建线性过渡的扩展方法，这可能是该类库最常用的方法
- ★ 优势
- 以少量代码创建复杂过渡效果
- 像游戏开发引擎那样,可在Update()中决定过渡效果的每一帧你要做出的行为
- 功能并不局限于动画,它修改任何可能的类型、任何可能的属性,例如使用模拟数据对程序进行测试正是作者在尝试中的用法之一
- ⚠ 劣势
- 性能不稳定 ( 相对于StoryBoard与VisualState等组件而言 )
- 支持过渡的属性类型受限较大，虽然提供了接口以解决这个问题，但将线性插值的计算交由接口的实现类仍然不是方便的做法
[![pAu2vOP.md.png](https://s21.ax1x.com/2024/09/15/pAu2vOP.md.png)](https://imgse.com/i/pAu2vOP)

## StateMachine
- 对于任何类型 [ where T : class , new() ] 可使用如下代码创建线性过渡
- 例如对一个100×100的Grid执行以下过渡
\`\`\`csharp
private RotateTransform rotateTransform = new RotateTransform(-280, 50, 50);
private TranslateTransform translateTransform = new TranslateTransform(-100, -50);
private ScaleTransform scaleTransform = new ScaleTransform(2, 2, 50, 50);

private void GD_MouseEnter(object sender, System.Windows.Input.MouseEventArgs e)
{
    GD.Transition()
        .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
        .SetProperty(x => x.Opacity, 0.2)
        .SetProperty(x => x.CornerRadius,new CornerRadius(15))
        .SetParams((x) =>
        {
            x.Duration = 0.4;
            x.Completed = () =>
            {
                Notification.Message("过渡完成 √");
            };
        })
        .Start();
}
\`\`\`
- 但默认可用状态机过渡的属性终究是有限类型,如何让自定义的类型也能支持状态机呢?
- 步骤1.实现一个Class1，它是支持状态机过渡的自定义类型
- 这里Class1是Thickness和CornerRadius的复合
- 需要实现接口方法Interpolate（）, steps是插值数量 , 你需要自定义如何将两个 Class1 拆成steps份均匀的插值
\`\`\`csharp
public class Class1 : ILinearInterpolation
{
public object Current { get; set; }
public List<object?> Interpolate(object? current, object? target, int steps)
{
    List<object?> result = new List<object?>();

    var v1 = current as Class1 ?? new Class1();
    var v2 = target as Class1 ?? new Class1();
    var itemsA = ILinearInterpolation.CornerRadiusComputing(v1.CornerRadius, v2.CornerRadius, steps);
    var itemsB = ILinearInterpolation.ThicknessComputing(v1.Thickness, v2.Thickness, steps);
    for (var i = 0; i < itemsA.Count; i++)
    {
        var temp = new Class1();
        temp.CornerRadius = itemsA[i] as CornerRadius? ?? new CornerRadius();
        temp.Thickness = itemsB[i] as Thickness? ?? new Thickness();
        result.Add(temp);
    }

    return result;
}


public Class1() { Current = this; }
public Class1(CornerRadius cornerRadius, Thickness thickness) { Current = this; CornerRadius = cornerRadius; Thickness = thickness; }
public CornerRadius CornerRadius { get; set; } = new CornerRadius();
public Thickness Thickness { get; set; } = new Thickness();
}
\`\`\`
- 步骤2.实现一个Class2，它是包含Class1属性的类型,是实际需要使用状态机的类型
\`\`\`csharp
public class Class2
{
public Class2() { }

public Class1 Class1 { get; set; } = new Class1();

//…… 其它属性
}
\`\`\`
- 步骤3.到这一步，你已可以对Class2.Class1应用状态机的过渡功能
\`\`\`csharp
Class1 T1 = new Class1();
Class1 T2 = new Class1(new CornerRadius(10), new Thickness(2, 3, 1, 0));

Class2 TargetClass2 = new Class2();

TargetClass2.Transition()
   .SetProperty(x => x.Class1, T2)
   .SetParams((x) =>
   {
       x.Duration = 2;
       x.Start = () =>
       {
            Notification.Message($"旧的 Thickness {TargetClass2.Class1.Thickness}\n" +
                    $"旧的 CornerRadius {TargetClass2.Class1.CornerRadius}");
       };
       x.Completed = () =>
       {
            Notification.Message($"新的 Thickness {TargetClass2.Class1.Thickness}\n" +
                    $"新的 CornerRadius {TargetClass2.Class1.CornerRadius}");
       };
   })
   .Start();
\`\`\`
---
## TransitionParams 
- 包含系列参数用于修饰此次过渡效果的细节
- 过渡效果相关的参数
- 过渡创建相关的参数
- 生命周期相关的参数

|属性|类型|默认|意义|
|--------|-----|-------|-------|
|Duration|double|0|动画持续时间 ( 单位: s )|
|Start|Action|null|在动画开始前执行一次|
|Update|Action|null|在动画的每一帧开始前执行一次|
|LateUpdate|Action|null|在动画的每一帧结束后执行一次|
|Completed|Action|null|在动画结束后执行一次|
|IsQueue|bool|false|新启用的动画是否排队,不排队就意味着会打断正在执行的动画|
|IsLast|bool|false|是否为最后一个被执行的动画,如果是则意味着会清空正在排队中的动画|
|IsUnique|bool|true|如果存在一个指向同一State的过渡动画,是否还要继续执行此动画|
|FrameRate|int|165|动画帧率|
|WaitTime|double|0.008|基本用不到,但如果发现有些地方概率无法触发动画或者概率抽搐,则可适当增加这个值|
|Acceleration|double|0|加速度,使得每一帧的等待时间在平面图中呈现出斜率为Acceleration的直线|

- 应用场景
- 为StateVector设置过渡参数 ( Lambda )
- 为Transition()设置过渡参数 ( Lambda )

\`\`\`csharp
Set((x)=>
{
x.Duration = 0.1;
x.IsLast = true;
x.Update = () =>
{
Notification.Message("一帧开始前");
};
})
\`\`\`
---
## State & StateVector & IConditionalTransition
- State描述某一时刻对象的属性值
- StateVector描述在何种条件下创建何种过渡
- IConditionalTransition接口允许在实例对象达成指定条件时自动创建过渡
- 示例
- 鼠标进入控件时,令其背景透明度过渡为0.2
- 鼠标离开控件时,令其背景透明度过渡为0
- Xaml - View
\`\`\`xml
<UserControl.DataContext>
<local:MButtonViewModel x:Name="ViewModel"/>
</UserControl.DataContext>
\`\`\`
- C# - View
\`\`\`csharp
public partial class MButton : UserControl
{
public MButton()
{
    InitializeComponent();
    this.StateMachineLoading(ViewModel);
}
}
\`\`\`
- C# - ViewModel
\`\`\`csharp
public class MButtonViewModel : ViewModelBase<MButtonViewModel, MButtonModel>
{
public MButtonViewModel() { }

public static State Start = State.FromObject(new MButtonViewModel())
    .SetName("defualt")
    .SetProperty(x => x.HoverBackgroundOpacity, 0)
    .ToState();
public static State MouseIn = State.FromObject(new MButtonViewModel())
    .SetName("mouseInside")
    .SetProperty(x => x.HoverBackgroundOpacity, 0.2)
    .ToState();

public StateVector<MButtonViewModel> Condition { get; set; } = StateVector<MButtonViewModel>.Create()
    .AddCondition(x => x.IsMouseInside, MouseIn, (x) => { x.Duration = 0.2; })
    .AddCondition(x => !x.IsMouseInside, Start, (x) => { x.Duration = 0.2; });

public override bool IsMouseInside
{
    get => base.IsMouseInside;
    set
    {
        base.IsMouseInside = value;

        OnConditionsChecked();
        //鼠标进出控件时修改IsMouseInside
        //IsMouseInside被修改时检查是否满足条件,若满足,则切换State
    }
}
}
\`\`\`

---
---

# 扩展方法
## string
- 值转换
\`\`\`csharp
string valueA = "-123.7";
string valueB = "TrUE";
string valueC = "#1e1e1e";
//三个待被转换的值

var result1 = valueA.ToInt();
var result2 = valueA.ToDouble();
var result3 = valueA.ToFloat();
//转换成数字

var result4 = valueB.ToBool();
//转换成bool

var result5 = valueC.ToBrush();
//转换成Brush
\`\`\`
- 模糊匹配
\`\`\`csharp
string template = "abcdefg";
//这是待匹配的字符串

string sourceA = "abc";
List<string> sourceB = new List<string>()
{
"abcdegf",
"cbdgafe"
};
//这是匹配源

var similarity1 = sourceA.LevenshteinDistance(template)
//返回最短编辑距离

var similarity2 = sourceA.JaroWinklerDistance(template)
//返回近似度

var result3 = template.BestMatch(sourceB, 3);
//编辑距离小于3且最小的结果

var result4 = template.BestMatch(sourceB, 0.5);
//近似度大于0.5且最大的结果
\`\`\`
- 文件夹生成操作
\`\`\`csharp
string folderNameA = "FF1";
string folderNameB = "FF2";
string folderNameC = "FF3";
//文件夹的名字

var result1 = folderNameA.CreatFolder();
//从.exe位置开始,创建名为"FF1"的文件夹

var result2 = folderNameC.CreatFolder(folderNameA,folderNameB);
//从.exe位置开始,创建名为"FF1/FF2/FF3"的文件夹
\`\`\`
- Xml 和 Json 序列化
\`\`\`csharp
string folderName = "Data";
//假设文件需要放在Data文件夹内

string fileName1 = "firstPersondata";
string fileName2 = "secondPersondata";
//假设这是两份文件的文件名

var target = new Person();
//假设需要将一个Person实例序列化存储

var result1 = fileName1.CreatXmlFile(folderName.CreatFolder(), target);
var result2 = fileName2.CreatJsonFile(folderName.CreatFolder(), target);
//分别存储为.xml和.json文件
\`\`\`
- Xml 和 Json 反序列化
\`\`\`csharp
string folderName = "Data";

string fileName1 = "firstPersondata";
string fileName2 = "secondPersondata";

string AbsPathA = Path.Combine(folderName.CreatFolder(), $"{fileName1}.xml");
string AbsPathB = Path.Combine(folderName.CreatFolder(), $"{fileName2}.json");
var dataA = File.ReadAllText(AbsPathA);
var dataB = File.ReadAllText(AbsPathB);
//拿到原始数据

var result1 = dataA.XmlParse<Person>();
var result2 = dataB.JsonParse<Person>();
//反序列化
\`\`\`
- 正则操作
\`\`\`csharp
string sourceA = "[1]wkhdkjhk[a][F3]https:awijdioj.mp3fwafw";
string sourceB = "awdhttps://aiowdjoajfo.comawd&*(&d)*dhttps://tn.comdawd";
//原始数据

var resultA = sourceA.CaptureBetween("https:", ".mp3");
//捕获所有包含在"https:"和".mp3"中间的字符串

var resultB = sourceB.CaptureLike("https://", "com");
//捕获所有符合先出现"https://"再出现"com"特征的字符串,特征可以是多个
\`\`\`
- 密码强度
\`\`\`csharp
string password = "12345678";
int Level = password.CheckPasswordStrength(MinLength=8);
//返回0~4的整数代表密码强度
\`\`\`

---
---

# 用户控件
- ## ☆ Using
- C#
\`\`\`csharp
using MinimalisticWPF;
\`\`\`
- XAML
\`\`\`xml
xmlns:mn="clr-namespace:MinimalisticWPF;assembly=MinimalisticWPF"
\`\`\`
- 不使用Width/Height调整大小,而是带有Wise、Size字样的属性,最后通过Margin调整位置
- 需要使用例如"#1e1e1e"的深色背景板,很多控件都是白边透明底的,浅色背景板效果不佳
- ## ☆ MButton
![Effect](https://s21.ax1x.com/2024/09/09/pAeLPyQ.png)
## Property
- Click
- WiseHeight
- WiseWidth
- Text
- TextBrush
- FontSizeRatio
- EdgeBrush
- EdgeThickness
- HoverBrush
- CornerRadius
---
- ## ☆ MTopBar
![pAmMfv8.md.png](https://s21.ax1x.com/2024/09/09/pAmMfv8.md.png)
![pAmQnVH.md.png](https://s21.ax1x.com/2024/09/09/pAmQnVH.md.png)
## Property
- WiseHeight
- WiseWidth
- Title
- SizeRatio
- EdgeBrush
- EdgeThickness
- HoverBrush
- CornerRadius
- Icon
---
- ## ☆ MPasswordBox
![Effect](https://s21.ax1x.com/2024/09/09/pAeLEoq.png)
![Effect](https://s21.ax1x.com/2024/09/09/pAeLQOJ.png)
## Property
- WiseHeight
- WiseWidth
- FontSizeRatio
- Password
- Replace
---
- ### ☆ MProgressBar
![Effect](https://s21.ax1x.com/2024/09/09/pAeLkes.png)
## Property
- Size
- Value
- Shape
- Thickness
- BottomBrush
- FillBrush
- TextBrush
- FontSizeRatio
- IsReverse
- StartAngle
- EndAngle
---
- ### ☆ Notification
[![pAKM40S.png](https://s21.ax1x.com/2024/09/18/pAKM40S.png)](https://imgse.com/i/pAKM40S)
[![pAKMhm8.png](https://s21.ax1x.com/2024/09/18/pAKMhm8.png)](https://imgse.com/i/pAKMhm8)
## 消息框调用示例
\`\`\`csharp
    if (Notification.Select("Are you sure you want to check the weather ?"))
    {
        Notification.Message("Weather");
    }
\`\`\`

---
---

# Web服务
- ## 高德
- using
\`\`\`csharp
using MinimalisticWPF.GaoDeServices;
\`\`\`
- 前往获取ApiKey https://console.amap.com/dev/key/app
\`\`\`csharp
protected override void OnSourceInitialized(EventArgs e)
{
    base.OnSourceInitialized(e);

    GaoDeAPISet.Awake(Key: "Your_Api_Key", IsUpdateIP: true);
    //[ IsUpdateIP ] 描述本次加载是否要重新读取IP信息
}
\`\`\`
- IPService
- 获取当前IP
\`\`\`csharp
var ip = await IPService.GetIP();
MessageBox.Show(ip.GetCombined());
\`\`\`
- 依据地区名称获取行政编码
\`\`\`csharp
var adcode = await IPService.GetAdCode("都江堰");
MessageBox.Show(adcode);
\`\`\`
- WeatherService
- 依据当前IP获取天气
\`\`\`csharp
var weathers = await WeatherService.GetWeathers();
MessageBox.Show(weathers[0].GetCombined());
\`\`\`
- 依据地区名称获取天气
\`\`\`csharp
var weathers = await WeatherService.GetWeathers("都江堰");
MessageBox.Show(weathers[0].GetCombined());
\`\`\`
- weather[0] 代表今天的天气
            `;

            // 使用 marked.js 转换 Markdown 内容
            this.Markdown = marked(markdownContent);
        }
    })
</script>

</html>