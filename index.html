<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/2.0.0/marked.min.js"></script>
</head>

<!--代码框样式-->
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #595757;
    }

    .code-container {
        position: relative;
        background-color: #282c34;
        color: #fff;
        border-radius: 5px;
        border: 1px solid white;
        padding: 5px;
        margin-bottom: 0px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .copy-button {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #61dafb;
        border: none;
        color: #282c34;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
    }
</style>

<!--版本选择框样式-->
<style>
    /* 自定义选择框样式 */
    .custom-select {
        color: rgb(88, 222, 255);
        /* 文字颜色 */
        background-color: #363333;
        /* 背景颜色 */
        padding: 5px;
        /* 内边距 */
        border-radius: 5px;
        /* 圆角 */
        cursor: pointer;
        /* 鼠标指针样式 */
        margin-left: 0%;
        width: 120px;
        text-align: center;
        transition: background-color 0.3s, color 0.3s;
        /* 过渡效果 */
    }

    option {
        text-align: center;
    }

    .custom-select:hover {
        background-color: #95d4de7a;
    }

    .custom-select:focus {
        background-color: #444;
    }
</style>

<!--整体布局样式-->
<style>
    header {
        background: #363333;
        color: white;
        padding: 10px 0;
        text-align: center;
        border-radius: 10px;
    }

    p {
        width: 800px;
        /* 设置段落的宽度 */
        overflow-wrap: break-word;
        /* 允许在单词内部换行 */
    }

    h1 {
        color: #00fff2;
    }

    h2 {
        color: aquamarine;
    }

    h3 {
        color: rgb(246, 249, 167);
        width: 700px;
    }

    div {
        border-radius: 10px;
        overflow-y: auto;
    }

    .container {
        display: flex;
        height: calc(100vh - 60px);
    }

    nav {
        overflow-y: auto;
        width: 200px;
        background-color: #444343;
        padding: 15px;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        border-radius: 10px;
    }

    nav button {
        padding: 5px;
        color: rgb(101, 250, 163);
        text-align: left;
        margin: 5px 0;
        border-radius: 5px;
        background-color: transparent;
        width: 100%;
        font-size: 20px;
    }

    nav button:hover {
        background-color: #ffffff51;
    }

    .content {
        flex-grow: 1;
        padding: 15px;
        background-color: #444343;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
    }
</style>

<!--MarkDown样式-->
<style>
    th,
    td {
        color: white;
        border: 1px solid white;
    }

    p,
    li,
    code,
    summary {
        color: white;
        overflow-x: auto;
    }

    img {
        overflow-x: auto;
    }
</style>

<body>
    <div id="app">
        <header>
            <h1>MinimalisticWPF</h1>
            <h2>探索简洁、清晰、易于管理的WPF动画实现方案</h2>
            <section>版本 ⇨
                <select v-model="Version" class="custom-select">s
                    <option value="1.5.x">V1.5.x </option>
                    <option value="1.8.x">V1.8.x </option>
                    <option value="更新详情">Updates</option>
                </select>
                <div v-html="renderedMarkdown"></div>
            </section>
        </header>

        <!--V1.9.x-->
        <div v-show="Version==='更新详情'">
            <div class="container">
                <nav>
                    <h1>目录</h1>
                    <button @Click="C182">v 1.8.2</button>
                    <button @Click="C185">v 1.8.5</button>
                    <button @Click="C187">v 1.8.7</button>
                    <button @Click="C188">v 1.8.8</button>
                </nav>
                <div class="content">
                    <diV v-show="Area!='C182'&&Area!='C185'&&Area!='C187'&&Area!='C188'">
                        <h1>历史版本变动</h1>
                        <p>选择版本以查看详情</p>
                    </diV>
                    <div v-show="Area==='C182'">
                        <h1>[ V 1.8.2 ]</h1>
                        <p>1.动画可以通过设置 [ LoopTime ] 参数实现循环播报,当你设置为 int.MaxValue 时,代表无限循环</p>
                        <p>2.动画可以通过设置 [ IsAutoReverse ] 参数实现自动返回到动画起始状态</p>
                    </div>
                    <div v-show="Area==='C185'">
                        <h1>[ V 1.8.5 ]</h1>
                        <p>1.生命周期已支持 [ async ] 操作</p>
                        <p>2.可在定义阶段使用 [ Preload() ] 预载帧数据</p>
                        <div id="C185-1"></div>
                    </div>
                    <div v-show="Area==='C187'">
                        <h1>[ V 1.8.7 ]</h1>
                        <h2>1.为AOP(面向切面编程)的实现提供了简化的流程</h2>
                        <h3>接下来我们以拦截TObj的GetName方法调用为例</h3>
                        <p>(1)首先,将需要拦截的属性/方法抽象到一个接口中</p>
                        <div id="C187-1"></div>
                        <p>(2)接着,创建TObj实例的代理对象pro,并拦截GetName方法</p>
                        <p>- 此时GetName方法在执行前、执行后均会执行额外的自定义逻辑</p>
                        <p>- 此时GetName方法的返回值已经被覆写</p>
                        <div id="C187-2"></div>
                        <p>(3)最后,通过pro对象调取的GetName方法已能执行你SetMethod中扩展/覆写的新逻辑,你还可以通过SetPropertySetter与SetPropertyGetter对Name属性的get器和set器调用做拦截并扩展/覆写,并且,如果你为pro代理的Name属性赋值,那么obj原始对象的Name属性也会做出同等变化(除非你覆写了默认逻辑)
                        </p>
                        <h2>2.使用户控件可像Page那样,在指定容器内切换</h2>
                        <p>(1)首先,用作页面的用户控件需要实现IPageNavigate接口</p>
                        <div id="C187-3"></div>
                        <p>(2)接着,在XAML中使用特定容器MPageBox</p>
                        <div id="C187-4"></div>
                        <p>(3)最后,可以使用唯一名称或控件类型实现页面切换</p>
                        <div id="C187-5"></div>
                        <h2>3.减少帧数据计算过程中List的扩容行为</h2>
                        <P>创建List时提前依据帧数定义了初始长度,理论可以减少不必要的扩容操作以优化性能</P>
                    </div>
                    <div v-show="Area==='C188'">
                        <h1>[ V 1.8.8 ]</h1>
                        <h2>1.修改AOP扩展/覆写所使用的委托定义</h2>
                        <div id="C188-1"></div>
                        <P>解释：新增一个last参数,它接收上一个方法的返回值</P>
                    </div>
                </div>
            </div>
        </div>

        <!--V1.8.x-->
        <div v-show="Version==='1.8.x'">
            <div class="container">
                <nav>
                    <h1>目录</h1>
                    <button @Click="a1Click">Ⅰ 简介</button>
                    <button @Click="a2Click">Ⅱ 入门</button>
                    <button @Click="a3Click">Ⅲ State</button>
                    <button @Click="a4Click">Ⅳ StateVector</button>
                    <button @Click="a5Click">Ⅴ 生命周期</button>
                    <button @Click="a6Click">Ⅵ UnSafe机制</button>
                    <button @Click="a7Click">Ⅶ 最佳实践</button>
                    <button @Click="a8Click">Ⅷ 常见问题</button>
                    <div>
                        <button @click="expend">Ⅸ 更多 {{ ExpendText }}</button>
                        <div v-show="isMoreOptionsVisible">
                            <button style="color: palegoldenrod;" @click="a9Click">动画参数</button>
                            <button style="color: palegoldenrod;" @click="a10Click">插值接口</button>
                            <button style="color: palegoldenrod;" @click="a11Click">过渡控制器</button>
                            <button style="color: palegoldenrod;" @click="a12Click">过渡执行器</button>
                        </div>
                    </div>
                </nav>
                <div class="content">
                    <div v-show="Area==='1'">
                        <h1>简介</h1>
                        <h2>1.MinimalisticWPF是什么?</h2>
                        <h3>一套WPF动画实现方案 [ 核心 ]</h3>
                        <p>- 它完全绕开WPF原生动画系统,转而将注意力放在 [ 属性 ] 本身,通过计算并应用插值,实现动画</p>
                        <p>- 它允许你像游戏引擎中的 [ 状态机 ] 那样,通过预先设定一些 [ 条件 → 动画 ] 对照关系,自动修改属性值从而实现动画效果</p>
                        <h2>2.MinimalisticWPF的特点?</h2>
                        <h3>简洁、灵活</h3>
                        <p>- 完全以C#代码实现动画</p>
                        <p>- 不受 [ 依赖属性 ] 限制 , 只要 [ 属性 ] 可读写 , 都可对其计算并应用插值</p>
                        <p>- 轻松控制动画帧 , 就像Unity的Update()、Start()那样</p>
                        <p>- 可以用于一些数据模拟场景 , 计算模拟数据的逻辑可依据接口定制</p>
                        <h2>3.MinimalisticWPF的缺陷?</h2>
                        <p>- 性能尚未得到验证</p>
                        <p>- 特殊旋转角处理效果不理想</p>
                        <h2>4.其它WPF相关功能的简化 [ 扩展 ]</h2>
                        <p>- string扩展包含了常见的值转换,正则捕获,模糊匹配操作</p>
                        <p>- AOP(面向切面编程)流程简化,你可轻松为自定义类型的属性/方法做拦截,并扩展/修改它们的调用逻辑 [ V 1.8.7 及以上 ]</p>
                        <p>- UserControl仅一次接口实现,即可作为Page,在特定容器MPageBox中切换 [ V 1.8.7 及以上 ]</p>
                    </div>
                    <div v-show="Area==='2'">
                        <h1>入门</h1>
                        <h2>1.创建你的第一个动画效果</h2>
                        <h3>以一个Grid控件为例，创建持续2s的动画</h3>
                        <p>效果:</p>
                        <p>1.透明度变为0.3</p>
                        <p>2.宽度和高度均变为200</p>
                        <div id="cd2-1"></div>
                        <h2>2.使用TransitionBoard绘板实现动画效果复用</h2>
                        <p>为Grid类创建一个通用的TransitionBoard绘板</p>
                        <div id="cd2-2"></div>
                        <p>Grid实例可以直接用TransitionBoard绘板启动动画</p>
                        <div id="cd2-3"></div>
                        <h2>3.使用State绘板实现动画效果复用</h2>
                        <p>为Grid类创建一个通用的State绘板</p>
                        <div id="cd2-4"></div>
                        <p>Grid实例可以直接用State绘板启动动画</p>
                        <div id="cd2-5"></div>
                        <p>tips:</p>
                        <p>State必须拥有Name</p>
                        <p>State作为绘板使用时,需要在动画启动时传入一次参数</p>
                        <h2 style="color: rgb(75, 228, 225);">现在,你已熟悉该库最为常见的使用场景！</h2>
                        <h3 style="color: rgb(255, 255, 255);">接下来的建议:</h3>
                        <h3 style="color: rgb(255, 255, 255);">1.State和StateVector - 允许像Unity状态机那样,使用条件连接并自动执行动画</h3>
                        <h3 style="color: rgb(255, 255, 255);">2.生命周期 - 丰富动画的执行过程</h3>
                        <h3 style="color: rgb(255, 255, 255);">3.UnSafe机制 - 像搭积木那样实现动画</h3>
                        <h3 style="color: rgb(255, 255, 255);">4.最佳实践 - 完全后端的动画实现方案</h3>
                        <h3 style="color: rgb(255, 255, 255);">5.接口 - 更多可能性的支持</h3>
                    </div>
                    <div v-show="Area==='3'">
                        <h1>State</h1>
                        <h2>1.State是什么?</h2>
                        <p>一个类型,用于描述对象在某个时刻的属性值,也就是这个对象在某一时刻的 [ 状态 ]</p>
                        <h2>2.消耗少量性能,记录一个对象在某一时刻的状态 Type-based</h2>
                        <p>(1)记录过程不涉及额外的反射、遍历操作</p>
                        <p>(2)只能记录指定的属性</p>
                        <div id="cd3-1"></div>
                        <h2>3.消耗大量性能,但允许你自动记录对象所有受支持的属性值 Object-based</h2>
                        <p>(1)⚠ 记录过程包括大量反射、遍历操作</p>
                        <p>(2)可以通过ToState(false)表明记录所有受支持的属性,而不局限于手动指定过的属性</p>
                        <div id="cd3-2"></div>
                        <h2>4.记录的状态可以用来干什么?</h2>
                        <h3>(1)启动动画,这在 [ 入门 ] 已经演示过</h3>
                        <h3>(2)☆ 与 <button style="color: lime;background-color:transparent"
                                @Click="a4Click">StateVecotr</button> 结合使用</h3>
                    </div>
                    <div v-show="Area==='4'">
                        <h1>StateVector</h1>
                        <h2>1.StateVector是什么?</h2>
                        <p>假设有一个实例对象Instance和一个State实例,你希望Instance满足条件Condition时,自动将Instance切换为State记录的状态,这个过程会是个自动生成的平滑动画,StateVector描述了这种
                            [ 条件 → 状态 ] 的连接关系</p>
                        <h2>2.如何定义它?</h2>
                        <p>设立两个区间,Grid.Width在进入到区间时可以自动过渡到对应的状态</p>
                        <p>注意:</p>
                        <p>(1)实际使用中,条件一般是更为严谨的</p>
                        <p>(2)若要使得这种自动生成动画生效,需要实现IConditionalTransition接口</p>
                        <p>(3)具体实现请参阅 <button style="color: lime;background-color:transparent"
                                @Click="a7Click">最佳实践</button></p>
                        <div id="cd4-1"></div>
                    </div>
                    <div v-show="Area==='5'">
                        <h1>生命周期</h1>
                        <h2>阶段:</h2>
                        <h3>Start - 动画开始前执行一次</h3>
                        <h3>Update - 动画每帧执行一次</h3>
                        <h3>LateUpdate - 动画每帧结束后执行一次</h3>
                        <h3>Completed - 动画结束时执行一次</h3>
                        <h2>应用:</h2>
                        <h3>1.定义委托</h3>
                        <div id="cd5-1"></div>
                        <h3>2.传入委托 ( 这里直接写Lambda了 )</h3>
                        <h3>- TransitionBoard.SetParams()内</h3>
                        <h3>- StateVecotr.AddCondition()内最后一个参数</h3>
                        <div id="cd5-2"></div>
                    </div>
                    <div v-show="Area==='6'">
                        <h1>UnSafe机制</h1>
                        <h2>1.为什么会存在Unsafe机制?</h2>
                        <h3>相对于Safe而言:</h3>
                        <p>(1)无条件开始执行动画效果</p>
                        <p>(2)过程不可被打断</p>
                        <h3>用处:</h3>
                        <p>将复杂动画拆解为一个一个的 [ 分量 ] , 例如多个Grid都拥有动画效果 , 但很多效果都是相同的 , 只有那么一小块存在差异 ，这时就可以将小块差异独立拆解为 [ 分量A ]
                            ，相同部分记录为 [ 分量B ] ，那么每个Grid实例在开始动画前 , 都可以修改实例的 [ 分量A ] , 而静态的 [ 分量B ]不变，最终，同时执行 [ 分量A ]与[ 分量B
                            ] 就能使得每个Grid既有共同点，也有差异点 </p>
                        <p>也就是说,全局只需要一个static的[ 分量B ]和若干非static的[ 分量A ]就足够了,然后在启动动画前依据条件修改若干[ 分量A ],那么每个实例都可拥有独立的动画效果
                        </p>
                        <h2>2.实战案例</h2>
                        <h3>首先,做个需求分析</h3>
                        <p>以两个Grid控件为例:</p>
                        <p>共同点:宽度和高度都变为100(Safe)</p>
                        <p>差异化:GD1透明度变为0.8；GD2透明度变为0.3(UnSafe)</p>
                        <h3>开始定义UnSafe动画与Safe动画</h3>
                        <p>- 这里为了方便演示,定义了两个UnSafe动画</p>
                        <p>- 实际上它的最佳应用场景是为一个 [ 用户控件 ] 做差异化动画 , 设想每个Grid都有一个UnSafeAnimation属性 , 你只需要修改这个属性 ,
                            就可以令Grid行为做出差异化</p>
                        <div id="cd6-1"></div>
                        <h3>启动!</h3>
                        <p>注意:</p>
                        <p>BeginTransition方法一定会打断Safe动画,因此Unsafe需要在Safe前启动</p>
                        <div id="cd6-2"></div>
                    </div>
                    <div v-show="Area==='7'">
                        <h1>最佳实践</h1>
                        <h2>MVVM模式下,实现一个密码框,其边框颜色会依据密码强度做出变化</h2>
                        <h3>回顾: State与StateVector</h3>
                        <p>1.思路拆解:</p>
                        <p>(1)需要1个State表示密码长度不符合时的边框颜色状态</p>
                        <p>(2)密码强度分1~4,所以又需要4个State表示对应状态下的边框颜色</p>
                        <p>(3)需要一个StateVector来描述 [ 条件 → State ] 关系</p>
                        <p>(4)每次密码改变时,应当唤醒StateVector去做条件判断</p>
                        <h3>2.DataContext代码实现</h3>
                        <p>密码框的颜色绑定为 [ PasswordStrengthColor属性 ]</p>
                        <p>密码改变时,其Set器内需要调用 [ OnConditionsChecked() ]以唤醒StateVector </p>
                        <div id="cd7-1"></div>
                        <h3>3.DataContext实现完毕后,需要在Code-Behind激活状态机</h3>
                        <p>这个方法只有FrameworkElement可用</p>
                        <div id="cd7-2"></div>
                        <p>DataContext建议在XAML内定义</p>
                        <div id="cd7-4"></div>
                        <h3>4.ViewModel为什么可以拥有OnConditionsChecked()</h3>
                        <p>因为ViewModelBase继承了StateViewModelBase,而StateViewModelBase实现了一些必要的接口</p>
                        <p>(1)INotifyPropertyChanged - 这个我想无需多言,用过MVVM都懂</p>
                        <p>(2)IConditionalTransition - 这个接口是你可以用 [ this.StateMachineLoading(ViewModel) ] 激活条件切换功能的关键组件
                        </p>
                        <p>(3)这里是它的定义,几乎是MVVM下最小实现单元</p>
                        <div id="cd7-3"></div>
                    </div>
                    <div v-show="Area==='8'">
                        <h2>P1. 为什么控件的Width和Height无法应用动画效果?</h2>
                        <h3>2024-10-15</h3>
                        <p>解释:</p>
                        <p>Margin不结合HorizontalAlignment与VerticalAlignment使用时 , 宽高会受到限制</p>
                        <p>方案:</p>
                        <p>1.直接对Margin属性加载动画</p>
                        <p>2.设置HorizontalAlignment与VerticalAlignment可以分别解锁Width和Height的限制</p>
                    </div>
                    <div v-show="Area==='9'">
                        <h1>动画参数表</h1>
                        <table>
                            <thead>
                                <tr>
                                    <th>属性</th>
                                    <th>类型</th>
                                    <th>默认值</th>
                                    <th>含义</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Start</td>
                                    <td>Action</td>
                                    <td>null</td>
                                    <td>在动画开始前执行一次</td>
                                </tr>
                                <tr>
                                    <td>Update</td>
                                    <td>Action</td>
                                    <td>null</td>
                                    <td>在动画的每一帧开始前执行一次</td>
                                </tr>
                                <tr>
                                    <td>LateUpdate</td>
                                    <td>Action</td>
                                    <td>null</td>
                                    <td>在动画的每一帧结束后执行一次</td>
                                </tr>
                                <tr>
                                    <td>Completed</td>
                                    <td>Action</td>
                                    <td>null</td>
                                    <td>在动画结束后执行一次</td>
                                </tr>
                                <tr>
                                    <td>FrameRate</td>
                                    <td>int</td>
                                    <td>120</td>
                                    <td>帧率 （ HZ ）</td>
                                </tr>
                                <tr>
                                    <td>Duration</td>
                                    <td>double</td>
                                    <td>0 s</td>
                                    <td>持续时间 （ S ）</td>
                                </tr>
                                <tr>
                                    <td>IsAutoReverse</td>
                                    <td>bool</td>
                                    <td>false</td>
                                    <td>动画结束后是否自动回到原状</td>
                                </tr>
                                <tr>
                                    <td>LoopTime</td>
                                    <td>int</td>
                                    <td>0</td>
                                    <td>循环播报次数</td>
                                </tr>
                                <tr>
                                    <td>Acceleration</td>
                                    <td>double</td>
                                    <td>0</td>
                                    <td>加速率 , 取值范围 [-1,1]</td>
                                </tr>
                                <tr>
                                    <td>IsUnSafe</td>
                                    <td>bool</td>
                                    <td>false</td>
                                    <td>是否启用Unsafe机制</td>
                                </tr>
                                <tr>
                                    <td>IsQueue</td>
                                    <td>bool</td>
                                    <td>false</td>
                                    <td>是否排队等待执行</td>
                                </tr>
                                <tr>
                                    <td>IsLast</td>
                                    <td>bool</td>
                                    <td>false</td>
                                    <td>是否在动画结束时清除动画队列</td>
                                </tr>
                                <tr>
                                    <td>IsUnique</td>
                                    <td>bool</td>
                                    <td>true</td>
                                    <td>如果已经有一个动画指向一个指定名称的状态，
                                        这次是否应该将动画添加到队列中，即是否
                                        动画是独一无二的</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div v-show="Area==='10'">
                        <h1>线性插值工具</h1>
                        <h2>ILinearInterpolation 接口</h2>
                        <h3>什么是线性插值?</h3>
                        <p>给出一个起始值start与目标值end,然后假定你需要steps个步骤数,从start变换到end,那么变换过程中的每个中间值就是一个 [ 插值 ]</p>
                        <p>当插值在 [ 值/时间 ] 图中呈现出直线时,称之为 [ 线性 ]</p>
                        <h3>为什么要有这个接口?</h3>
                        <p>因为状态机默认只支持以下类型的属性做出线性过渡:</p>
                        <p>(1) double</p>
                        <p>(2) Brush</p>
                        <p>(3) Point</p>
                        <p>(4) Transform</p>
                        <p>(5) CornerRadius</p>
                        <p>(6) Thickness</p>
                        <h3>而ILinearInterpolation将允许你自定义的类型参与到状态机过渡</h3>
                        <h2>1.静态工具</h2>
                        <h3>Computing(object? start, object? end, int steps) 函数</h3>
                        <p>(1) start起始值</p>
                        <p>(2) end目标值</p>
                        <p>(3) steps插值总数</p>
                        <h3>在你实现接口的过程中,会要求你实现 [ List&lt;object?&gt; Interpolate(object? current, object? target, int
                            steps) ] 方法,这是一个线性插值算法实现</h3>
                        <p>很多时候你自定义的类型可能大多是几种属性的复合,因此可以使用静态工具便捷地实现自定义插值算法</p>
                        <p style="color: rgb(255, 111, 238);">注意 : 不一定非得是线性的!</p>
                        <p style="color: rgb(255, 111, 238);">如果,你的插值在xy图中呈现出其它非线性关系,那么OK,没问题,动画就是会按照你的插值效果来执行</p>
                        <p style="color: rgb(255, 111, 238);">例如 : 一个正弦曲线,甚至是贝塞尔曲线…………只要你能实现这个自定义插值逻辑</p>
                        <p style="color: Lime;">所以,动画效果其实是可以高度自定义的,这也是为什么插值接口如此重要的原因</p>
                        <h2>2.实践案例</h2>
                        <p>(1) 你自定义了Class1,希望它能参与状态机的过渡效果</p>
                        <p>在此过程中你使用插值工具方便了接口方法的实现</p>
                        <div id="cd8-1"></div>
                        <p>(2) 你自定义了Class2,并拥用一个Class1属性</p>
                        <div id="cd8-2"></div>
                        <p>(3) 你已能够对自定义的Class1做出线性过渡</p>
                        <div id="cd8-3"></div>
                    </div>
                    <div v-show="Area==='11'">
                        <h1>StateMachine</h1>
                        <h2>管理对象实例在不同State间的切换行为</h2>
                    </div>
                    <div v-show="Area==='12'">
                        <h1>Interpreter</h1>
                        <h2>实现对象从一个State过渡至另一个State</h2>
                    </div>
                </div>
            </div>
        </div>

        <!--V1.5.x-->
        <div v-show="Version === '1.5.x'">
            <h2>中文文档 V{{ Version }}</h2>
            <div style="background-color: #444;" v-html="Markdown"></div>
        </div>
    </div>
</body>

<!--代码框创建-->
<script>
    //文本+容器ID
    function createCodeBox(code, id) {
        // 创建代码容器
        const container = document.createElement('div');
        container.className = 'code-container';

        // 创建复制按钮
        const button = document.createElement('button');
        button.className = 'copy-button';
        button.innerText = '复制';
        button.onclick = () => copyToClipboard(code);

        // 创建预格式代码块
        const pre = document.createElement('pre');
        const codeElement = document.createElement('code');
        codeElement.innerText = code;
        pre.appendChild(codeElement);

        // 将按钮和代码块添加到容器中
        container.appendChild(button);
        container.appendChild(pre);

        // 将代码容器添加到页面上
        document.getElementById(id).appendChild(container);
    }

    function copyToClipboard(code) {
        // 创建临时文本域
        const tempInput = document.createElement('textarea');
        tempInput.value = code;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
        alert('复制成功！');
    }
</script>

<!--Vue实例-->
<script>
    new Vue({
        el: '#app',
        methods: {
            a1Click() {
                this.Area = '1';
            },
            a2Click() {
                this.Area = '2';
            },
            a3Click() {
                this.Area = '3';
            },
            a4Click() {
                this.Area = '4';
            },
            a5Click() {
                this.Area = '5';
            },
            a6Click() {
                this.Area = '6';
            },
            a7Click() {
                this.Area = '7';
            },
            a8Click() {
                this.Area = '8';
            },
            a9Click() {
                this.Area = '9';
            },
            a10Click() {
                this.Area = '10';
            },
            a11Click() {
                this.Area = '11';
            },
            a12Click() {
                this.Area = '12';
            },
            expend() {
                this.isMoreOptionsVisible = !this.isMoreOptionsVisible;
                this.ExpendText = this.isMoreOptionsVisible ? '▲' : '▼';
            },
            C182() {
                this.Area = 'C182';
            },
            C185() {
                this.Area = 'C185';
            },
            C187() {
                this.Area = 'C187';
            },
            C188() {
                this.Area = 'C188';
            }
        },
        data: {
            Version: '1.8.x',
            Area: '1',
            MarkDown: '',
            isMoreOptionsVisible: false,
            ExpendText: '▼',
        },
        mounted() {
            //代码框
            window.onload = function () {
                createCodeBox(`GD.Transition()
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .SetParams((x) =>
    {
        x.Duration = 2;
    })
    .Start();`, 'cd2-1');
                createCodeBox(`TransitionBoard<Grid> _board = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .SetParams((x) =>
    {
        x.Duration = 2;
    });`, 'cd2-2');
                createCodeBox(`GD.BeginTransition(_board);`, 'cd2-3');
                createCodeBox(`State _board = State.FromType<Grid>()
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState();

Action<TransitionParams> _params = (x) =>
{
    x.Duration = 2;
};`, 'cd2-4');
                createCodeBox(`GD.BeginTransition(_board, _params);`, 'cd2-5');
                createCodeBox(`State _board = State.FromType<Grid>()
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState();`, 'cd3-1');
                createCodeBox(`State _board = State.FromObject(new Grid())
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState(false);`, 'cd3-2');
                createCodeBox(`static State _board1 = State.FromType<Grid>()
    .SetName("Animation1")
    .SetProperty(x => x.Opacity, 0.3)
    .SetProperty(x => x.Width, 200)
    .SetProperty(x => x.Height, 200)
    .ToState();
static State _board2 = State.FromType<Grid>()
    .SetName("Animation2")
    .SetProperty(x => x.Opacity, 1)
    .SetProperty(x => x.Width, 100)
    .SetProperty(x => x.Height, 100)
    .ToState();

StateVector<Grid> _vector = StateVector<Grid>.Create()
    .AddCondition(x => x.Width > 10 && x.Width <= 20, _board1, (x) => { x.Duration = 0.2; })
    .AddCondition(x => x.Width > 20 && x.Width <= 100, _board2, (x) => { x.Duration = 0.2; });`, 'cd4-1');
                createCodeBox(`Action<TransitionParams> _params = (x) =>
{
    x.Duration = 2;
    x.Start = () =>
    {

    };
    x.Update = () =>
    {

    };
    x.LateUpdate = () =>
    {

    };
    x.Completed = () =>
    {

    };
};`, 'cd5-1');
                createCodeBox(`StateVector<Grid> _vector = StateVector<Grid>.Create()
    .AddCondition(x => x.Width > 20 && x.Width <= 100, _board2,
    (x) =>
    {
        x.Duration = 0.2;
        x.Start = () =>
        {

        };
        x.Update = () =>
        {

        };
        x.LateUpdate = () =>
        {

        };
        x.Completed = () =>
        {

        };
    });`, 'cd5-2');
                createCodeBox(`static TransitionBoard<Grid> Safe = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Width, 100)
    .SetProperty(x => x.Height, 100)
    .SetParams((x) =>
    {
        x.Duration = 1;
    });
TransitionBoard<Grid> UnSafe_1 = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Opacity, 1)
    .SetParams((x) =>
    {
        x.IsUnSafe = true;
        x.Duration = 1;
    });
TransitionBoard<Grid> UnSafe_2 = Transition.CreateBoardFromType<Grid>()
    .SetProperty(x => x.Opacity, 1)
    .SetParams((x) =>
    {
        x.IsUnSafe = true;
        x.Duration = 1;
    });`, 'cd6-1');
                createCodeBox(`if (GD1.Width > 1)
{
    UnSafe_1.SetProperty(x => x.Opacity, 0.8);
}

if (GD2.Height > 1)
{
    UnSafe_2.SetProperty(x => x.Opacity, 0.3);
}

GD1.BeginTransition(UnSafe_1);
GD2.BeginTransition(UnSafe_2);

GD1.BeginTransition(Safe);
GD2.BeginTransition(Safe);`, 'cd6-2');
                createCodeBox(`/// <summary>
/// 作为密码框的DataContext
/// </summary>
public class MPasswordBoxViewModel : ViewModelBase<MPasswordBoxViewModel, MPasswordBoxModel>
{
    public MPasswordBoxViewModel() { }

    //默认颜色
    public static State Default = State.FromType<MPasswordBoxViewModel>()
        .SetName("default")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.White)
        .ToState();

    //密码强度有四个分级，对应四个不同的颜色
    public static State Level1 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L1")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Tomato)
        .ToState();
    public static State Level2 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L2")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Yellow)
        .ToState();
    public static State Level3 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L3")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Cyan)
        .ToState();
    public static State Level4 = State.FromType<MPasswordBoxViewModel>()
        .SetName("L4")
        .SetProperty(x => x.PasswordStrengthColor, Brushes.Lime)
        .ToState();

    //达到指定密码强度时，切换至指定的State
    public StateVector<MPasswordBoxViewModel> Condition { get; set; } = StateVector<MPasswordBoxViewModel>.Create()
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 0, Default, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 1, Level1, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 2, Level2, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 3, Level3, (x) => { x.Duration = 0.3; })
        .AddCondition(x => x.TruePassword.CheckPasswordStrength(8) == 4, Level4, (x) => { x.Duration = 0.3; });

    //真实密码
    public string TruePassword
    {
        get => Model.TruePassword;
        set
        {
            Model.TruePassword = value;
            string result = string.Empty;
            for (int i = 0; i < value.Length; i++)
            {
                result += ReplacingCharacters;
            }
            UIPassword = result;
            OnPropertyChanged(nameof(TruePassword));

            OnConditionsChecked();
            //由IConditionalTransition接口规定的方法
            //StateViewModelBase是实现MVVM并且接入状态机系统【条件切换】功能的最小实现单元,它帮你实现了INotifyPropertyChanged与IConditionalTransition接口
            //调用这句话即可在密码改变时,检测密码强度并执行动画
        }
    }

    /// <summary>
    /// 用户视觉可见的密码
    /// </summary>
    public string UIPassword
    {
        get => Model.UIPassword;
        set
        {
            Model.UIPassword = value;
            OnPropertyChanged(nameof(UIPassword));
        }
    }

    /// <summary>
    /// 用于替换真实密码的字符
    /// </summary>
    public string ReplacingCharacters
    {
        get => Model.ReplacingCharacters;
        set
        {
            Model.ReplacingCharacters = value;
            string result = string.Empty;
            for (int i = 0; i < TruePassword.Length; i++)
            {
                result += ReplacingCharacters;
            }
            UIPassword = result;
            OnPropertyChanged(nameof(ReplacingCharacters));
        }
    }

    /// <summary>
    /// 密码强度对应的边框颜色
    /// </summary>
    public Brush PasswordStrengthColor
    {
        get => Model.PasswordStrengthColor;
        set
        {
            Model.PasswordStrengthColor = value;
            OnPropertyChanged(nameof(PasswordStrengthColor));
        }
    }
}`, 'cd7-1');
                createCodeBox(`public MPasswordBox()
{
    InitializeComponent();
    this.StateMachineLoading(ViewModel);
}`, 'cd7-2');
                createCodeBox(`    /// <summary>
    /// MVVM下,使ViewModel支持状态机的示例写法
    /// </summary>
    /// <typeparam name="T">ViewModel的真实类型</typeparam>
    public abstract class StateViewModelBase<T> : INotifyPropertyChanged, IConditionalTransition<T> where T : class
    {
        public event PropertyChangedEventHandler? PropertyChanged;
        public void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public T? Target { get; set; }
        public StateMachine? StateMachine { get; set; }
        public StateVector<T>? StateVector { get; set; }
        public void OnConditionsChecked()
        {
            if (Target == null)
            {
                Target = this as T ?? throw new ArgumentException($"This instance cannot be converted to an instance of type [ {nameof(T)} ]");
            }
            if (StateVector != null && StateMachine != null)
            {
                StateVector?.Check(Target, StateMachine);
            }
        }
    }`, 'cd7-3');
                createCodeBox(`<UserControl.DataContext>
    <local:MPasswordBoxViewModel x:Name="ViewModel"
                                 CornerRadius="10"
                                 FontSizeConvertRate="0.7"
                                 TextBrush="White"/>
</UserControl.DataContext>`, 'cd7-4');
                createCodeBox(`public class Class1 : ILinearInterpolation
{
    public object Current { get; set; }
    public List<object?> Interpolate(object? current, object? target, int steps)
    {
        List<object?> result = new List<object?>();

        var v1 = current as Class1 ?? new Class1();
        var v2 = target as Class1 ?? new Class1();
        var itemsA = ILinearInterpolation.CornerRadiusComputing(v1.CornerRadius, v2.CornerRadius, steps);
        var itemsB = ILinearInterpolation.ThicknessComputing(v1.Thickness, v2.Thickness, steps);
        for (var i = 0; i < itemsA.Count; i++)
        {
            var temp = new Class1();
            temp.CornerRadius = itemsA[i] as CornerRadius? ?? new CornerRadius();
            temp.Thickness = itemsB[i] as Thickness? ?? new Thickness();
            result.Add(temp);
        }

        return result;
    }


    public Class1() { Current = this; }
    public Class1(CornerRadius cornerRadius, Thickness thickness) { Current = this; CornerRadius = cornerRadius; Thickness = thickness; }
    public CornerRadius CornerRadius { get; set; } = new CornerRadius();
    public Thickness Thickness { get; set; } = new Thickness();
}`, 'cd8-1');
                createCodeBox(`public class Class2
{
    public Class2() { }

    public Class1 TransitionableProperty = new Class1();
}`, 'cd8-2');
                createCodeBox(`var test = new Class2();
var newValue = new Class1();
test.Transition()
    .SetProperty(x => x.TransitionableProperty, newValue)
    .SetParams((p) =>
    {
        p.Duration = 1;
    })
    .Start();`, 'cd8-3');
                createCodeBox(`var data = gd.Transition()
              .SetProperty(x => x.Width, 100)
              .SetParams((x) =>
              {
                  x.Duration = 0.5;
                  x.StartAsync = async () =>
                  {
                      await Task.Delay(500);
                  };
              })
              .PreLoad();
data.Start();`, 'C185-1');
                createCodeBox(`public interface IPropertyProxy : IProxy
{
    string Name { get; set; }
    string GetName();
}
public class TObj : IPropertyProxy
{
    public TObj() { }

    public string Name { get; set; } = "defaultValue";

    public string GetName()
    {
        return "defaultResult";
    }
}`, 'C187-1');
                createCodeBox(`TObj obj = new TObj();
IPropertyProxy pro = obj.CreateProxy<IPropertyProxy>();
pro.SetMethod(nameof(pro.GetName), 
            object? (args) => { MessageBox.Show($"before method call"); return null; }, 
            object? (args) => { return "coverage result"; }, 
            object? (args) => { MessageBox.Show($"after method call"); return null; });`, 'C187-2');
                createCodeBox(`public partial class Page1 : UserControl, IPageNavigate
{
    public Page1()
    {
        InitializeComponent();
    }

    public string GetPageName()
    {
        return "page1";
    }

    public object GetPage()
    {
        return new Page1();
    }
}`, 'C187-3');
                createCodeBox(`xmlns:mn="clr-namespace:MinimalisticWPF;assembly=MinimalisticWPF"

<mn:MPageBox x:Name="Pages" 
             NavigateMode="None" 
             SlideDirection="RightToLeft" 
             Acceleration="1" 
             FrameRate="120"/>`, 'C187-4');
                createCodeBox(`  Pages.Navigate("Page1");

  Pages.Navigate(typeof(Page1));`, 'C187-5');
                createCodeBox(`pro.SetMethod(nameof(pro.GetName),
              object? (args, last) => { MessageBox.Show($"before default method"); return "AOP before\\n"; },
              object? (args, last) => { return $"{last}AOP Coverage \\n"; },
              object? (args, last) => { MessageBox.Show($"results :\\n{last}AOP after\\n"); return null; });`, 'C188-1');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
                createCodeBox(``, '');
            }


            //Markdown
            const markdownContent = `
## 修改 
<details>
<summary>V1.5.0 即将弃用</summary>

- Transition() 改为支持任何 [ where T : class ,new() ] 类型
- State限制修改，需要是公开静态字段或公开属性
- StateVector限制修改，需要写作公开属性
- 支持Transform过渡
- Translate
- Scale
- Rotate
- 支持Point过渡
- 支持CornerRadius过渡
- 支持Thickness过渡
- 接口ILinearInterpolation允许自定义的类型作为可过渡属性
</details>

<details>
<summary>V1.5.1 即将弃用</summary>

- Acceleration 加速度支持
- 删除状态机运作时,部分不必要的对象生成操作 
</details>

<details>
<summary>V1.5.2 即将弃用</summary>

- 修复了NET6.0框架下动画效果异常的问题
</details>

<details>
<summary>V1.5.3 即将弃用</summary>

- State 性能优化
- 基于 Object
- 在State初始化时执行了大量反射、LINQ操作
- 允许自动化地记录一个object所有受支持的属性
- 基于 Type
- 在State初始化时不执行任何反射、LINQ操作
- 只能手动指定需要修改的属性
- 使用
- State.FromType<>() / StateMachineTransition( StateRecordModes.Type )
- State.FromObject() / StateMachineTransition( StateRecordModes.Object )
- TransitionInterpreter 逻辑优化
- 解决了频繁切换State可能导致的抽搐问题
</details>

<details>
<summary>V1.5.6</summary>

- 修复
- 帧率处于 57~61 时，渐变结果可能失真
- 帧率低于 100 时，高速切换State可能导致启动状态机失败
- 帧率为 0 时，出现错误
- 持续时间为 0 时，出现错误
- 调整
- 帧率默认值已调整为 120Hz
- 帧率限制为 1~240 ,超出范围将被自动矫正
- 新增
- class.IsSatisfy() 允许你基于实例对象是否满足指定的条件,决定是否启动预先描述的过渡
\`\`\`csharp
    var board = GD.Transition()
        .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
        .SetParams((x) =>
        {
            x.Duration = 3;
            x.Acceleration = 1;
        });

    var result = GD.IsSatisfy(x => x.Width < 1000, board, true);
    //参数1.条件(必须)
    //参数2.若满足条件,则执行此过渡(非必须)
    //参数3.过渡效果若为基于对象的,是否启用白名单机制(非必须)
\`\`\`
- 2.0.0 版本预告
- ★ 对文档进行大幅优化
- ★ 开放更多原本只可以在状态机系统内部运作的功能
- 修复更多潜在问题
- 尝试进一步优化性能   
- 增加更多常用的扩展方法
- ⚠ 移除所有非核心组件
</details>

## 核心功能
- [状态机系统 - 对指定实例的指定属性创建线性过渡](#状态机系统)
- [StateMachine 执行过渡功能的核心组件]() 
- [TransitionParams 调整过渡效果细节]()
- [MVVM 使用State与StateVector]()
- 可参与状态机过渡的属性类型
- double
- Brush
- Transform      
- CornerRadius
- Thickness
- Point
- ★ ILinearInterpolation ( 该接口使得任意自定义类型支持状态机过渡 )
## 辅助功能
- [扩展方法](#扩展方法)
- [string]
- 值转换
- 模糊匹配
- 分析工具（例如提取html中的资源地址）
- 密码强度
- [用户控件](#用户控件)
- 统一的深色主题
- 字体大小自适应控件高度
- 所有动画效果都基于状态机系统,它们既是直接可用的,也是状态机系统的实践
- Notification - 玻璃风格的通知/选择框
- MProgressBar - 条状/环状自由切换的进度条
- MTopBar - 程序顶侧栏
## 非核心组件
###### MinimalisticWPF命名空间不包括下述服务，另需引用
- [Web服务](#Web服务)
- [ 高德 ] WebApi
- IP服务
- 天气服务

## 支持框架
- [.NET6.0-windows] 
- [.NET8.0-windows]
## 获取
- [github][1]
- [nuget][2]

[1]: https://github.com/ChengduNeusoftUniversity-FengJunjie-Y22/MinimalisticWPF
[2]: https://www.nuget.org/packages/MinimalisticWPF/

---

# 状态机系统
- State & StateVecotr 为MVVM而生 ,可通过预先设置条件实现状态的自动切换
- StateMachine 理论可对任何类型的属性做出线性过渡，非MVVM下，几乎所有类型都包含一个用于快速为对象实例创建线性过渡的扩展方法，这可能是该类库最常用的方法
- ★ 优势
- 以少量代码创建复杂过渡效果
- 像游戏开发引擎那样,可在Update()中决定过渡效果的每一帧你要做出的行为
- 功能并不局限于动画,它修改任何可能的类型、任何可能的属性,例如使用模拟数据对程序进行测试正是作者在尝试中的用法之一
- ⚠ 劣势
- 性能不稳定 ( 相对于StoryBoard与VisualState等组件而言 )
- 支持过渡的属性类型受限较大，虽然提供了接口以解决这个问题，但将线性插值的计算交由接口的实现类仍然不是方便的做法
[![pAu2vOP.md.png](https://s21.ax1x.com/2024/09/15/pAu2vOP.md.png)](https://imgse.com/i/pAu2vOP)

## StateMachine
- 对于任何类型 [ where T : class , new() ] 可使用如下代码创建线性过渡
- 例如对一个100×100的Grid执行以下过渡
\`\`\`csharp
private RotateTransform rotateTransform = new RotateTransform(-280, 50, 50);
private TranslateTransform translateTransform = new TranslateTransform(-100, -50);
private ScaleTransform scaleTransform = new ScaleTransform(2, 2, 50, 50);

private void GD_MouseEnter(object sender, System.Windows.Input.MouseEventArgs e)
{
    GD.Transition()
        .SetProperty(x => x.RenderTransform, rotateTransform, translateTransform, scaleTransform)
        .SetProperty(x => x.Opacity, 0.2)
        .SetProperty(x => x.CornerRadius,new CornerRadius(15))
        .SetParams((x) =>
        {
            x.Duration = 0.4;
            x.Completed = () =>
            {
                Notification.Message("过渡完成 √");
            };
        })
        .Start();
}
\`\`\`
- 但默认可用状态机过渡的属性终究是有限类型,如何让自定义的类型也能支持状态机呢?
- 步骤1.实现一个Class1，它是支持状态机过渡的自定义类型
- 这里Class1是Thickness和CornerRadius的复合
- 需要实现接口方法Interpolate（）, steps是插值数量 , 你需要自定义如何将两个 Class1 拆成steps份均匀的插值
\`\`\`csharp
public class Class1 : ILinearInterpolation
{
public object Current { get; set; }
public List<object?> Interpolate(object? current, object? target, int steps)
{
    List<object?> result = new List<object?>();

    var v1 = current as Class1 ?? new Class1();
    var v2 = target as Class1 ?? new Class1();
    var itemsA = ILinearInterpolation.CornerRadiusComputing(v1.CornerRadius, v2.CornerRadius, steps);
    var itemsB = ILinearInterpolation.ThicknessComputing(v1.Thickness, v2.Thickness, steps);
    for (var i = 0; i < itemsA.Count; i++)
    {
        var temp = new Class1();
        temp.CornerRadius = itemsA[i] as CornerRadius? ?? new CornerRadius();
        temp.Thickness = itemsB[i] as Thickness? ?? new Thickness();
        result.Add(temp);
    }

    return result;
}


public Class1() { Current = this; }
public Class1(CornerRadius cornerRadius, Thickness thickness) { Current = this; CornerRadius = cornerRadius; Thickness = thickness; }
public CornerRadius CornerRadius { get; set; } = new CornerRadius();
public Thickness Thickness { get; set; } = new Thickness();
}
\`\`\`
- 步骤2.实现一个Class2，它是包含Class1属性的类型,是实际需要使用状态机的类型
\`\`\`csharp
public class Class2
{
public Class2() { }

public Class1 Class1 { get; set; } = new Class1();

//…… 其它属性
}
\`\`\`
- 步骤3.到这一步，你已可以对Class2.Class1应用状态机的过渡功能
\`\`\`csharp
Class1 T1 = new Class1();
Class1 T2 = new Class1(new CornerRadius(10), new Thickness(2, 3, 1, 0));

Class2 TargetClass2 = new Class2();

TargetClass2.Transition()
   .SetProperty(x => x.Class1, T2)
   .SetParams((x) =>
   {
       x.Duration = 2;
       x.Start = () =>
       {
            Notification.Message($"旧的 Thickness {TargetClass2.Class1.Thickness}\n" +
                    $"旧的 CornerRadius {TargetClass2.Class1.CornerRadius}");
       };
       x.Completed = () =>
       {
            Notification.Message($"新的 Thickness {TargetClass2.Class1.Thickness}\n" +
                    $"新的 CornerRadius {TargetClass2.Class1.CornerRadius}");
       };
   })
   .Start();
\`\`\`
---
## TransitionParams 
- 包含系列参数用于修饰此次过渡效果的细节
- 过渡效果相关的参数
- 过渡创建相关的参数
- 生命周期相关的参数

|属性|类型|默认|意义|
|--------|-----|-------|-------|
|Duration|double|0|动画持续时间 ( 单位: s )|
|Start|Action|null|在动画开始前执行一次|
|Update|Action|null|在动画的每一帧开始前执行一次|
|LateUpdate|Action|null|在动画的每一帧结束后执行一次|
|Completed|Action|null|在动画结束后执行一次|
|IsQueue|bool|false|新启用的动画是否排队,不排队就意味着会打断正在执行的动画|
|IsLast|bool|false|是否为最后一个被执行的动画,如果是则意味着会清空正在排队中的动画|
|IsUnique|bool|true|如果存在一个指向同一State的过渡动画,是否还要继续执行此动画|
|FrameRate|int|165|动画帧率|
|WaitTime|double|0.008|基本用不到,但如果发现有些地方概率无法触发动画或者概率抽搐,则可适当增加这个值|
|Acceleration|double|0|加速度,使得每一帧的等待时间在平面图中呈现出斜率为Acceleration的直线|

- 应用场景
- 为StateVector设置过渡参数 ( Lambda )
- 为Transition()设置过渡参数 ( Lambda )

\`\`\`csharp
Set((x)=>
{
x.Duration = 0.1;
x.IsLast = true;
x.Update = () =>
{
Notification.Message("一帧开始前");
};
})
\`\`\`
---
## State & StateVector & IConditionalTransition
- State描述某一时刻对象的属性值
- StateVector描述在何种条件下创建何种过渡
- IConditionalTransition接口允许在实例对象达成指定条件时自动创建过渡
- 示例
- 鼠标进入控件时,令其背景透明度过渡为0.2
- 鼠标离开控件时,令其背景透明度过渡为0
- Xaml - View
\`\`\`xml
<UserControl.DataContext>
<local:MButtonViewModel x:Name="ViewModel"/>
</UserControl.DataContext>
\`\`\`
- C# - View
\`\`\`csharp
public partial class MButton : UserControl
{
public MButton()
{
    InitializeComponent();
    this.StateMachineLoading(ViewModel);
}
}
\`\`\`
- C# - ViewModel
\`\`\`csharp
public class MButtonViewModel : ViewModelBase<MButtonViewModel, MButtonModel>
{
public MButtonViewModel() { }

public static State Start = State.FromObject(new MButtonViewModel())
    .SetName("defualt")
    .SetProperty(x => x.HoverBackgroundOpacity, 0)
    .ToState();
public static State MouseIn = State.FromObject(new MButtonViewModel())
    .SetName("mouseInside")
    .SetProperty(x => x.HoverBackgroundOpacity, 0.2)
    .ToState();

public StateVector<MButtonViewModel> Condition { get; set; } = StateVector<MButtonViewModel>.Create()
    .AddCondition(x => x.IsMouseInside, MouseIn, (x) => { x.Duration = 0.2; })
    .AddCondition(x => !x.IsMouseInside, Start, (x) => { x.Duration = 0.2; });

public override bool IsMouseInside
{
    get => base.IsMouseInside;
    set
    {
        base.IsMouseInside = value;

        OnConditionsChecked();
        //鼠标进出控件时修改IsMouseInside
        //IsMouseInside被修改时检查是否满足条件,若满足,则切换State
    }
}
}
\`\`\`

---
---

# 扩展方法
## string
- 值转换
\`\`\`csharp
string valueA = "-123.7";
string valueB = "TrUE";
string valueC = "#1e1e1e";
//三个待被转换的值

var result1 = valueA.ToInt();
var result2 = valueA.ToDouble();
var result3 = valueA.ToFloat();
//转换成数字

var result4 = valueB.ToBool();
//转换成bool

var result5 = valueC.ToBrush();
//转换成Brush
\`\`\`
- 模糊匹配
\`\`\`csharp
string template = "abcdefg";
//这是待匹配的字符串

string sourceA = "abc";
List<string> sourceB = new List<string>()
{
"abcdegf",
"cbdgafe"
};
//这是匹配源

var similarity1 = sourceA.LevenshteinDistance(template)
//返回最短编辑距离

var similarity2 = sourceA.JaroWinklerDistance(template)
//返回近似度

var result3 = template.BestMatch(sourceB, 3);
//编辑距离小于3且最小的结果

var result4 = template.BestMatch(sourceB, 0.5);
//近似度大于0.5且最大的结果
\`\`\`
- 文件夹生成操作
\`\`\`csharp
string folderNameA = "FF1";
string folderNameB = "FF2";
string folderNameC = "FF3";
//文件夹的名字

var result1 = folderNameA.CreatFolder();
//从.exe位置开始,创建名为"FF1"的文件夹

var result2 = folderNameC.CreatFolder(folderNameA,folderNameB);
//从.exe位置开始,创建名为"FF1/FF2/FF3"的文件夹
\`\`\`
- Xml 和 Json 序列化
\`\`\`csharp
string folderName = "Data";
//假设文件需要放在Data文件夹内

string fileName1 = "firstPersondata";
string fileName2 = "secondPersondata";
//假设这是两份文件的文件名

var target = new Person();
//假设需要将一个Person实例序列化存储

var result1 = fileName1.CreatXmlFile(folderName.CreatFolder(), target);
var result2 = fileName2.CreatJsonFile(folderName.CreatFolder(), target);
//分别存储为.xml和.json文件
\`\`\`
- Xml 和 Json 反序列化
\`\`\`csharp
string folderName = "Data";

string fileName1 = "firstPersondata";
string fileName2 = "secondPersondata";

string AbsPathA = Path.Combine(folderName.CreatFolder(), $"{fileName1}.xml");
string AbsPathB = Path.Combine(folderName.CreatFolder(), $"{fileName2}.json");
var dataA = File.ReadAllText(AbsPathA);
var dataB = File.ReadAllText(AbsPathB);
//拿到原始数据

var result1 = dataA.XmlParse<Person>();
var result2 = dataB.JsonParse<Person>();
//反序列化
\`\`\`
- 正则操作
\`\`\`csharp
string sourceA = "[1]wkhdkjhk[a][F3]https:awijdioj.mp3fwafw";
string sourceB = "awdhttps://aiowdjoajfo.comawd&*(&d)*dhttps://tn.comdawd";
//原始数据

var resultA = sourceA.CaptureBetween("https:", ".mp3");
//捕获所有包含在"https:"和".mp3"中间的字符串

var resultB = sourceB.CaptureLike("https://", "com");
//捕获所有符合先出现"https://"再出现"com"特征的字符串,特征可以是多个
\`\`\`
- 密码强度
\`\`\`csharp
string password = "12345678";
int Level = password.CheckPasswordStrength(MinLength=8);
//返回0~4的整数代表密码强度
\`\`\`

---
---

# 用户控件
- ## ☆ Using
- C#
\`\`\`csharp
using MinimalisticWPF;
\`\`\`
- XAML
\`\`\`xml
xmlns:mn="clr-namespace:MinimalisticWPF;assembly=MinimalisticWPF"
\`\`\`
- 不使用Width/Height调整大小,而是带有Wise、Size字样的属性,最后通过Margin调整位置
- 需要使用例如"#1e1e1e"的深色背景板,很多控件都是白边透明底的,浅色背景板效果不佳
- ## ☆ MButton
![Effect](https://s21.ax1x.com/2024/09/09/pAeLPyQ.png)
## Property
- Click
- WiseHeight
- WiseWidth
- Text
- TextBrush
- FontSizeRatio
- EdgeBrush
- EdgeThickness
- HoverBrush
- CornerRadius
---
- ## ☆ MTopBar
![pAmMfv8.md.png](https://s21.ax1x.com/2024/09/09/pAmMfv8.md.png)
![pAmQnVH.md.png](https://s21.ax1x.com/2024/09/09/pAmQnVH.md.png)
## Property
- WiseHeight
- WiseWidth
- Title
- SizeRatio
- EdgeBrush
- EdgeThickness
- HoverBrush
- CornerRadius
- Icon
---
- ## ☆ MPasswordBox
![Effect](https://s21.ax1x.com/2024/09/09/pAeLEoq.png)
![Effect](https://s21.ax1x.com/2024/09/09/pAeLQOJ.png)
## Property
- WiseHeight
- WiseWidth
- FontSizeRatio
- Password
- Replace
---
- ### ☆ MProgressBar
![Effect](https://s21.ax1x.com/2024/09/09/pAeLkes.png)
## Property
- Size
- Value
- Shape
- Thickness
- BottomBrush
- FillBrush
- TextBrush
- FontSizeRatio
- IsReverse
- StartAngle
- EndAngle
---
- ### ☆ Notification
[![pAKM40S.png](https://s21.ax1x.com/2024/09/18/pAKM40S.png)](https://imgse.com/i/pAKM40S)
[![pAKMhm8.png](https://s21.ax1x.com/2024/09/18/pAKMhm8.png)](https://imgse.com/i/pAKMhm8)
## 消息框调用示例
\`\`\`csharp
    if (Notification.Select("Are you sure you want to check the weather ?"))
    {
        Notification.Message("Weather");
    }
\`\`\`

---
---

# Web服务
- ## 高德
- using
\`\`\`csharp
using MinimalisticWPF.GaoDeServices;
\`\`\`
- 前往获取ApiKey https://console.amap.com/dev/key/app
\`\`\`csharp
protected override void OnSourceInitialized(EventArgs e)
{
    base.OnSourceInitialized(e);

    GaoDeAPISet.Awake(Key: "Your_Api_Key", IsUpdateIP: true);
    //[ IsUpdateIP ] 描述本次加载是否要重新读取IP信息
}
\`\`\`
- IPService
- 获取当前IP
\`\`\`csharp
var ip = await IPService.GetIP();
MessageBox.Show(ip.GetCombined());
\`\`\`
- 依据地区名称获取行政编码
\`\`\`csharp
var adcode = await IPService.GetAdCode("都江堰");
MessageBox.Show(adcode);
\`\`\`
- WeatherService
- 依据当前IP获取天气
\`\`\`csharp
var weathers = await WeatherService.GetWeathers();
MessageBox.Show(weathers[0].GetCombined());
\`\`\`
- 依据地区名称获取天气
\`\`\`csharp
var weathers = await WeatherService.GetWeathers("都江堰");
MessageBox.Show(weathers[0].GetCombined());
\`\`\`
- weather[0] 代表今天的天气
            `;

            // 使用 marked.js 转换 Markdown 内容
            this.Markdown = marked(markdownContent);
        }
    })
</script>

</html>